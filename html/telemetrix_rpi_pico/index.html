<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>telemetrix_rpi_pico.telemetrix_rpi_pico API documentation</title>
<meta name="description" content="Copyright (c) 2021 Alan Yorinks All rights reserved â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>telemetrix_rpi_pico.telemetrix_rpi_pico</code></h1>
</header>
<section id="section-intro">
<p>Copyright (c) 2021 Alan Yorinks All rights reserved.</p>
<p>This program is free software; you can redistribute it and/or
modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
Version 3 as published by the Free Software Foundation; either
or (at your option) any later version.
This library is distributed in the hope that it will be useful,f
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU
General Public License for more details.</p>
<p>You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
02110-1301
USA</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
 Copyright (c) 2021 Alan Yorinks All rights reserved.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
 Version 3 as published by the Free Software Foundation; either
 or (at your option) any later version.
 This library is distributed in the hope that it will be useful,f
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
 along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

&#34;&#34;&#34;
import struct
import sys
import threading
import time
from collections import deque

import serial
# noinspection PyPackageRequirementscd
from serial.serialutil import SerialException
# noinspection PyPackageRequirements
from serial.tools import list_ports

from telemetrix_rpi_pico.private_constants import PrivateConstants


# noinspection PyPep8,PyMethodMayBeStatic
class TelemetrixRpiPico(threading.Thread):
    &#34;&#34;&#34;
    This class exposes and implements a Telemetrix type
    API for the Raspberry Pi Pico.
    It uses threading to accommodate concurrency.
    It includes the public API methods as well as
    a set of private methods.

    &#34;&#34;&#34;

    def __init__(self, com_port=None, pico_instance_id=None,
                 sleep_tune=0.000001,
                 shutdown_on_exception=True,
                 reset_on_shutdown=True):

        &#34;&#34;&#34;

        :param com_port: e.g. COM3 or /dev/ttyACM0.
                         Only use if you wish to bypass auto com port
                         detection.

        :param pico_instance_id: If not specified, than don&#39;t do id check.
                                 Else contains a board&#39; s pico unique ID.
                                 This is passed as an array.

        :param sleep_tune: A tuning parameter (typically not changed by user)

        :param shutdown_on_exception: call shutdown before raising
                                      a RunTimeError exception, or
                                      receiving a KeyboardInterrupt exception

        :para reset_on_shutdown: Reset the board upon shutdown
        &#34;&#34;&#34;

        # initialize threading parent
        threading.Thread.__init__(self)

        # create the threads and set them as daemons so
        # that they stop when the program is closed

        # create a thread to interpret received serial data
        self.the_reporter_thread = threading.Thread(target=self._reporter)
        self.the_reporter_thread.daemon = True

        self.the_data_receive_thread = threading.Thread(target=self._serial_receiver)

        # flag to allow the reporter and receive threads to run.
        self.run_event = threading.Event()

        # check to make sure that Python interpreter is version 3.7 or greater
        python_version = sys.version_info
        if python_version[0] &gt;= 3:
            if python_version[1] &gt;= 7:
                pass
            else:
                raise RuntimeError(&#34;ERROR: Python 3.7 or greater is &#34;
                                   &#34;required for use of this program.&#34;)

        # save input parameters as instance variables
        self.com_port = com_port
        self.pico_instance_id = pico_instance_id
        self.sleep_tune = sleep_tune
        self.shutdown_on_exception = shutdown_on_exception
        self.reset_on_shutdown = reset_on_shutdown

        # create a deque to receive and process data from the pico
        self.the_deque = deque()

        # The report_dispatch dictionary is used to process
        # incoming report messages by looking up the report message
        # and executing its associated processing method.

        self.report_dispatch = {}

        # To add a command to the command dispatch table, append here.
        self.report_dispatch.update(
            {PrivateConstants.LOOP_COMMAND: self._report_loop_data})
        self.report_dispatch.update(
            {PrivateConstants.DEBUG_PRINT: self._report_debug_data})
        self.report_dispatch.update(
            {PrivateConstants.DIGITAL_REPORT: self._digital_message})
        self.report_dispatch.update(
            {PrivateConstants.ANALOG_REPORT: self._analog_message})
        self.report_dispatch.update(
            {PrivateConstants.FIRMWARE_REPORT: self._firmware_message})
        self.report_dispatch.update(
            {PrivateConstants.UNIQUE_ID_REPORT: self._report_unique_id})
        self.report_dispatch.update(
            {PrivateConstants.SERVO_UNAVAILABLE: self._servo_unavailable})
        self.report_dispatch.update(
            {PrivateConstants.I2C_READ_REPORT: self._i2c_read_report})
        self.report_dispatch.update(
            {PrivateConstants.I2C_WRITE_FAILED: self._i2c_write_failed})
        self.report_dispatch.update(
            {PrivateConstants.I2C_READ_FAILED: self._i2c_read_failed})
        self.report_dispatch.update(
            {PrivateConstants.SONAR_DISTANCE: self._sonar_distance_report})
        self.report_dispatch.update({PrivateConstants.DHT_REPORT: self._dht_report})

        # up to 16 pwm pins may be simultaneously active
        self.pwm_active_count = 0

        # dictionaries to store the callbacks for each pin
        self.analog_callbacks = {}

        self.digital_callbacks = {}

        self.i2c_callback = None
        self.i2c_callback2 = None

        self.i2c_0_active = False
        self.i2c_1_active = False

        # the trigger pin will be the key to retrieve
        # the callback for a specific HC-SR04
        self.sonar_callbacks = {}

        self.sonar_count = 0

        self.dht_callbacks = {}

        self.dht_count = 0

        # serial port in use
        self.serial_port = None

        # flag to indicate we are in shutdown mode
        self.shutdown_flag = False

        # debug loopback callback method
        self.loop_back_callback = None

        # flag to indicate the start of a new report
        # self.new_report_start = True

        # firmware version to be stored here
        self.firmware_version = []

        # reported pico_id
        self.reported_pico_id = []

        # flag to indicate if i2c was previously enabled
        self.i2c_enabled = False

        # Create a dictionary to store the pins in use.
        # Notice that gpio pins 23, 24 and 25 are not included
        # because the Pico does not support these GPIOs.

        # This dictionary is a list of gpio pins updated with the pin mode when a pin mode
        # is set.
        # It is created initially using a dictionary comprehension.
        self.pico_pins = {gpio_pin: PrivateConstants.AT_MODE_NOT_SET for gpio_pin in
                          range(23)}

        for pin in range(25, 29):
            self.pico_pins[pin] = PrivateConstants.AT_MODE_NOT_SET

        # creating a list of available sda and scl pins for i2c. If assigned the pins
        # value will be set to either 0 or 1 depending upon the i2c selected.
        self.i2c_sda_pins = {n: 255 for n in range(2, 21, 2)}
        self.i2c_sda_pins[26] = 255

        self.i2c_scl_pins = {n: 255 for n in range(3, 22, 2)}
        self.i2c_scl_pins[27] = 255

        self.the_reporter_thread.start()
        self.the_data_receive_thread.start()

        # neopixel data
        self.number_of_pixels = None

        self.neopixels_initiated = False

        print(f&#34;TelemetrixRpiPico:  Version {PrivateConstants.TELEMETRIX_VERSION}\n\n&#34;
              f&#34;Copyright (c) 2020 Alan Yorinks All Rights Reserved.\n&#34;)

        # using the serial link

        if not self.com_port:
            # user did not specify a com_port
            try:
                self._find_pico()
            except KeyboardInterrupt:
                if self.shutdown_on_exception:
                    self.shutdown()
        else:
            # com_port specified - set com_port and baud rate
            try:
                self._manual_open()
            except KeyboardInterrupt:
                if self.shutdown_on_exception:
                    self.shutdown()

        if self.serial_port:
            print(
                f&#34;Serial compatible device found and connected to&#34;
                f&#34; {self.serial_port.port}&#34;)

            self.serial_port.reset_input_buffer()
            self.serial_port.reset_output_buffer()

        # no com_port found - raise a runtime exception
        else:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;No pico Found or User Aborted Program&#39;)

        # allow the threads to run
        self._run_threads()

        print(&#39;Retrieving pico ID...&#39;)
        self._get_pico_id()
        # time.sleep(.2)
        print(f&#39;Pico Unique ID: {self.reported_pico_id}&#39;)

        if self.pico_instance_id:
            if self.reported_pico_id != self.pico_instance_id:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(f&#39;Incorrect pico ID: {self.reported_pico_id}&#39;)
            else:
                print(&#39;Valid pico ID Found.&#39;)
        # get pico firmware version and print it
        print(&#39;\nRetrieving Telemetrix4pico firmware ID...&#39;)
        self._get_firmware_version()
        # time.sleep(.3)
        if not self.firmware_version:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;Telemetrix4pico firmware version&#39;)

        else:
            print(f&#39;Telemetrix4pico firmware version: {self.firmware_version[0]}.&#39;
                  f&#39;{self.firmware_version[1]}&#39;)
        command = [PrivateConstants.ENABLE_ALL_REPORTS]
        self._send_command(command)

        # Have the server reset its data structures
        command = [PrivateConstants.RESET_DATA]
        self._send_command(command)

    def _find_pico(self):
        &#34;&#34;&#34;
        This method will search all potential serial ports for a pico
        board using its USB PID and VID.
        &#34;&#34;&#34;

        # a list of serial ports to be checked
        serial_ports = []

        print(&#39;Opening all potential serial ports...&#39;)
        the_ports_list = list_ports.comports()
        for port in the_ports_list:
            if port.pid is None:
                continue
            if port.pid != 10 or port.vid != 11914:
                continue
            try:
                self.serial_port = serial.Serial(port.device, 115200,
                                                 timeout=1, writeTimeout=0)
            except SerialException:
                continue
            # create a list of serial ports that we opened
            # make sure this is a pico board
            if port.pid == 10 and port.vid == 11914:
                serial_ports.append(self.serial_port)

                # display to the user
                print(&#39;\t&#39; + port.device)

                # clear out the serial buffers
                self.serial_port.reset_input_buffer()
                self.serial_port.reset_output_buffer()

    def _manual_open(self):
        &#34;&#34;&#34;
        Com port was specified by the user - try to open up that port

        &#34;&#34;&#34;
        # if port is not found, a serial exception will be thrown
        try:
            print(f&#39;Opening {self.com_port}...&#39;)
            self.serial_port = serial.Serial(self.com_port, 115200,
                                             timeout=1, writeTimeout=0)

            self._run_threads()
            # time.sleep(self.pico_wait)

            self._get_pico_id()
            if self.pico_instance_id:
                if self.reported_pico_id != self.pico_instance_id:
                    if self.shutdown_on_exception:
                        self.shutdown()
                    raise RuntimeError(f&#39;Incorrect pico ID: {self.reported_pico_id}&#39;)
            print(&#39;Valid pico ID Found.&#39;)
            # get pico firmware version and print it
            print(&#39;\nRetrieving Telemetrix4pico firmware ID...&#39;)
            self._get_firmware_version()

            if not self.firmware_version:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(f&#39;Telemetrix4pico Sketch Firmware Version Not Found&#39;)

            else:
                print(f&#39;Telemetrix4pico firmware version: {self.firmware_version[0]}.&#39;
                      f&#39;{self.firmware_version[1]}&#39;)
        except KeyboardInterrupt:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;User Hit Control-C&#39;)

    def pwm_write(self, pin, value):
        &#34;&#34;&#34;
        Set the specified pin to the specified value.

        :param pin: pico GPIO pin number

        :param value: pin value - size is determined by what was set for value_range
        when set_pin_mode_pwm_output was called.

        &#34;&#34;&#34;
        if self.pico_pins[pin] != PrivateConstants.AT_PWM_OUTPUT:
            raise RuntimeError(&#39;pwm_write: You must set the pin mode before performing &#39;
                               &#39;a PWM write.&#39;)
        value_msb = value &gt;&gt; 8
        value_lsb = value &amp; 0xff
        command = [PrivateConstants.PWM_WRITE, pin, value_msb, value_lsb]
        self._send_command(command)

    def digital_write(self, pin, value):
        &#34;&#34;&#34;
        Set the specified pin to the specified value.

        :param pin: pico GPIO pin number

        :param value: pin value (1 or 0)

        &#34;&#34;&#34;
        if self.pico_pins[pin] != PrivateConstants.AT_OUTPUT:
            raise RuntimeError(&#39;pwm_write: You must set the pin mode before performing &#39;
                               &#39;a digital write.&#39;)
        command = [PrivateConstants.DIGITAL_WRITE, pin, value]
        self._send_command(command)

    def disable_all_reporting(self):
        &#34;&#34;&#34;
        Disable reporting for all digital and analog input pins
        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_DISABLE_ALL, 0]
        self._send_command(command)

    def disable_analog_reporting(self, pin):
        &#34;&#34;&#34;
        Disables analog reporting for a single analog pin.

        :param pin: Analog pin number. For example for ADC, the number is 0.

        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_ANALOG_DISABLE, pin]
        self._send_command(command)

    def disable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Disables digital reporting for a single digital input.

        :param pin: GPIO Pin number.

        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_DIGITAL_DISABLE, pin]
        self._send_command(command)

    def enable_analog_reporting(self, pin):
        &#34;&#34;&#34;
        Enables analog reporting for the specified pin.

        :param pin: Analog pin number. For example for ADC0, the number is 0.


        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_ANALOG_ENABLE, pin]
        self._send_command(command)

    def enable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Enable reporting on the specified digital pin.

        :param pin: GPIO Pin number.
        &#34;&#34;&#34;

        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_DIGITAL_ENABLE, pin]
        self._send_command(command)

    def _get_pico_id(self):
        &#34;&#34;&#34;
        Retrieve pico-telemetrix pico id

        &#34;&#34;&#34;
        command = [PrivateConstants.RETRIEVE_PICO_UNIQUE_ID]
        self._send_command(command)
        # provide time for the reply
        time.sleep(.5)

    def _get_firmware_version(self):
        &#34;&#34;&#34;
        This method retrieves the
        pico-telemetrix firmware version

        &#34;&#34;&#34;
        command = [PrivateConstants.GET_FIRMWARE_VERSION]
        self._send_command(command)
        # provide time for the reply
        time.sleep(.5)

    # TBD
    def i2c_read(self, address, register, number_of_bytes,
                 callback=None, i2c_port=0, no_stop=False):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified register for
        the i2c device.


        :param address: i2c device address

        :param register: i2c register (or None if no register selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Required callback function to report i2c data as a
                   result of read command

       :param i2c_port: 0 = port 0, 1 = port 1

       :param no_stop: If true, master retains control of the bus at the end of the
                       transfer (no Stop is issued), and the next transfer will
                       begin with a Restart rather than a Start.


        callback returns a data list:
        [I2C_READ_REPORT, i2c_port, i2c_device_address, count of data bytes, data bytes,
        time-stamp]

        I2C_READ_REPORT = 10

        &#34;&#34;&#34;

        if not callback:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;I2C Read: A callback function must be specified.&#39;)

        # i2c_port = 0 for port 0
        if i2c_port == 0:
            if not self.i2c_0_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Write: set_pin_mode_i2c never called for i2c port 0.&#39;)
            else:
                self.i2c_callback = callback

        else:
            if not i2c_port == 1:
                if not self.i2c_0_active:
                    if self.shutdown_on_exception:
                        self.shutdown()
                    raise RuntimeError(
                        &#39;I2C Write: set_pin_mode_i2c never called for i2c port 1.&#39;)
                else:
                    self.i2c_callback2 = callback

        command = [PrivateConstants.I2C_READ, i2c_port, address, register,
                   number_of_bytes, no_stop]

        # no register specified
        if not register:
            command[3] = PrivateConstants.I2C_NO_REGISTER

        self._send_command(command)

    # TBD
    def i2c_write(self, address, args, i2c_port=0, no_stop=False):
        &#34;&#34;&#34;
        Write data to an i2c device.

        :param address: i2c device address

        :param args: A variable number of bytes to be sent to the device
                     passed in as a list.
                     NOTE: THIS MUST BE IN THE FORM OF A LIST.

        :param i2c_port: 0= port 0, 1 = port 1

        :param no_stop: If true, master retains control of the bus at the end of the
                       transfer (no Stop is issued), and the next transfer will
                       begin with a Restart rather than a Start.



        &#34;&#34;&#34;
        if not i2c_port:
            if not self.i2c_0_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Write: set_pin_mode i2c never called for i2c port 0.&#39;)

        elif i2c_port:
            if not self.i2c_1_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Write: set_pin_mode i2c never called for i2c port 2.&#39;)

        command = [PrivateConstants.I2C_WRITE, i2c_port, address, len(args), no_stop]

        for item in args:
            command.append(item)

        self._send_command(command)

    def neo_pixel_set_value(self, pixel_number, r=0, g=0, b=0, auto_show=False):
        &#34;&#34;&#34;
        Set the selected pixel in the pixel array on the Pico to
        the value provided.

        :param pixel_number: pixel number

        :param r: red value 0-255

        :param g: green value 0-255

        :param b: blue value 0-255

        :param auto_show: call show automatically

        &#34;&#34;&#34;
        if not self.neopixels_initiated:
            raise RuntimeError(&#39;You must call set_pin_mode_neopixel first&#39;)

        if pixel_number &gt; self.number_of_pixels:
            raise RuntimeError(&#39;Pixel number is out of legal range&#39;)

        if r and g and b not in range(256):
            raise RuntimeError(&#39;Pixel value must be in the range of 0-255&#39;)

        command = [PrivateConstants.SET_NEO_PIXEL, pixel_number, r, g, b, auto_show]
        self._send_command(command)

        if auto_show:
            self.neopixel_show()

    def neopixel_clear(self, auto_show=True):
        &#34;&#34;&#34;
        Clear all pixels

        :param auto_show: call show automatically

        &#34;&#34;&#34;
        if not self.neopixels_initiated:
            raise RuntimeError(&#39;You must call set_pin_mode_neopixel first&#39;)
        command = [PrivateConstants.CLEAR_ALL_NEO_PIXELS, auto_show]
        self._send_command(command)
        if auto_show:
            self.neopixel_show()

    def neopixel_fill(self, r=0, g=0, b=0, auto_show=True):
        &#34;&#34;&#34;
        Fill all pixels with specified value

        :param r: 0-255

        :param g: 0-255

        :param b: 0-255

        :param auto_show: call show automatically
        &#34;&#34;&#34;
        if not self.neopixels_initiated:
            raise RuntimeError(&#39;You must call set_pin_mode_neopixel first&#39;)
        if r and g and b not in range(256):
            raise RuntimeError(&#39;Pixel value must be in the range of 0-255&#39;)
        command = [PrivateConstants.FILL_ALL_NEO_PIXELS, r, g, b, auto_show]
        self._send_command(command)

        if auto_show:
            self.neopixel_show()

    def neopixel_show(self):
        &#34;&#34;&#34;
        Write the NeoPixel buffer stored in the Pico to the NeoPixel strip.

        &#34;&#34;&#34;
        if not self.neopixels_initiated:
            raise RuntimeError(&#39;You must call set_pin_mode_neopixel first&#39;)
        command = [PrivateConstants.SHOW_NEO_PIXELS]
        self._send_command(command)

    def loop_back(self, start_character, callback=None):
        &#34;&#34;&#34;
        This is a debugging method to send a character to the
        pico device, and have the device loop it back.

        :param start_character: The character to loop back. It should be
                                an integer.

        :param callback: Looped back character will appear in the callback method

        &#34;&#34;&#34;
        command = [PrivateConstants.LOOP_COMMAND, ord(start_character)]
        self.loop_back_callback = callback
        self._send_command(command)

    def set_pin_mode_analog_input(self, adc_number, differential=0, callback=None):
        &#34;&#34;&#34;
        Set a pin as an analog input.

        :param adc_number: ADC Number 0-3 - ADC 3 is the temp sensor

        :param differential: difference in previous to current value before
                             report will be generated

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for analog input pins = 3

        &#34;&#34;&#34;
        # make sure adc number is in range
        if not 0 &lt; adc_number &lt; 5:
            raise RuntimeError(&#39;Invalid ADC Number&#39;)
        self._set_pin_mode(adc_number, PrivateConstants.AT_ANALOG, differential,
                           callback=callback)

    def set_pin_mode_digital_input(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input.

        :param pin_number: pico GPIO pin number

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins = 2

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT, callback=callback)

    def set_pin_mode_digital_input_pullup(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input with pullup enabled.

        :param pin_number: pico GPIO pin number

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins with pullups enabled = 2

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT_PULLUP,
                           callback=callback)

    def set_pin_mode_digital_input_pull_down(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input with pull down enabled.

        :param pin_number: pico GPIO pin number

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins with pullups enabled = 2

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT_PULL_DOWN,
                           callback=callback)

    def set_pin_mode_digital_output(self, pin_number):
        &#34;&#34;&#34;
        Set a pin as a digital output pin.

        :param pin_number: pico GPIO pin number
        &#34;&#34;&#34;

        self._set_pin_mode(pin_number, PrivateConstants.AT_OUTPUT)

    def set_pin_mode_neopixel(self, pin_number=28, num_pixels=8,
                              fill_r=0, fill_g=0, fill_b=0):
        &#34;&#34;&#34;
        Initialize the pico for NeoPixel control. Fill with rgb values specified.

        Default: Set all the pixels to off.

        :param pin_number: neopixel GPIO control pin

        :param num_pixels: number of pixels in the strip

        :param fill_r: initial red fill value 0-255

        :param fill_g: initial green fill value 0-255

        :param fill_b: initial blue fill value 0-255


        &#34;&#34;&#34;
        if fill_r or fill_g or fill_g not in range(256):
            raise RuntimeError(&#39;Pixel value must be in the range of 0-255&#39;)

        self.number_of_pixels = num_pixels

        command = [PrivateConstants.INITIALIZE_NEO_PIXELS, pin_number,
                   self.number_of_pixels, fill_r, fill_g, fill_b]

        self._send_command(command)

        self.pico_pins[pin_number] = PrivateConstants.AT_NEO_PIXEL

        self.neopixels_initiated = True

    def set_pin_mode_pwm_output(self, pin_number, value_range=255):
        &#34;&#34;&#34;
        Enable a pin as a PWM pin. Maximum number of PWMs is 16.

        :param pin_number: pico GPIO pin number

        :param value_range: value range - 16 bits
        &#34;&#34;&#34;

        if pin_number in self.pico_pins:
            self.pico_pins[pin_number] = PrivateConstants.AT_PWM_OUTPUT
            if self.pwm_active_count &gt;= 15:
                raise RuntimeError(
                    &#39;set_pin_mode_pwm_output: number of active PWM pins is at maximum&#39;)

            if value_range &gt; 0xffff:
                raise RuntimeError(
                    &#39;set_pin_mode_pwm_output: value_range is limited to 16 bits&#39;)

            self.pwm_active_count += 1

            self._set_pin_mode(pin_number, PrivateConstants.AT_PWM_OUTPUT,
                               value_range=value_range)
        else:
            raise RuntimeError(&#39;Gpio Pin Number is invalid&#39;)

    # TBD
    def set_pin_mode_i2c(self, i2c_port=0, sda_gpio=4, scl_gpio=5):
        &#34;&#34;&#34;
        Establish the standard pico i2c pins for i2c utilization.

        :param i2c_port: 0 = i2c0, 1 = i2c1

        :param sda_gpio: gpio pin assigned to SDA

        :param scl_gpio: gpio pin assigned to SCL


        NOTES:
               1. THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE &lt;br&gt;
               2. Callbacks are set within the individual i2c read methods of this
              API.

              See i2c_read, and i2c_write

        &#34;&#34;&#34;
        # determine if the i2c port is specified correctly
        if i2c_port not in [0, 1]:
            raise RuntimeError(&#39;i2c port must be either a 0 or 1&#39;)
        # determine if the sda and scl gpio&#39;s are valid
        if sda_gpio not in self.i2c_sda_pins:
            raise RuntimeError(f&#39;GPIO {sda_gpio} is an invalid i2c SDA GPIO&#39;)
        if scl_gpio not in self.i2c_scl_pins:
            raise RuntimeError(f&#39;GPIO {scl_gpio} is an invalid i2c SCL GPIO&#39;)

        # are both GPIOs available?
        if not self.i2c_sda_pins[sda_gpio] == 255:
            raise RuntimeError(f&#39;GPIO SDA pin {sda_gpio} is already in use.&#39;)
        if not self.i2c_scl_pins[scl_gpio] == 255:
            raise RuntimeError(f&#39;GPIO SCL pin {scl_gpio} is already in use.&#39;)
        # both pins available - mark the sda and scl dictionaries appropriately
        self.i2c_sda_pins[sda_gpio] = self.i2c_scl_pins[scl_gpio] = i2c_port

        # now mark the pico_pins dictionary for these pins
        self.pico_pins[sda_gpio] = self.pico_pins[scl_gpio] = PrivateConstants.AT_I2C

        # determine if the specified sda or scl pin has already been
        # assigned.

        # test for i2c port 0
        if not i2c_port:
            self.i2c_0_active = True
        # port 1
        else:
            self.i2c_1_active = True

        command = [PrivateConstants.I2C_BEGIN, i2c_port, sda_gpio, scl_gpio]
        self._send_command(command)

    # TBD
    # def set_pin_mode_dht(self, pin, callback=None):
    #     &#34;&#34;&#34;
    #     NOT YET IMPLEMENTED!!!
    #
    #     :param pin: connection pin
    #
    #     :param callback: callback function
    #
    #     Error Callback: [Callback 0=DHT REPORT, DHT_ERROR=0, PIN, Error Number, Time]
    #
    #     Valid Data Callback: Callback 0=DHT REPORT, DHT_DATA=1, PIN, Humidity, Temperature Time]
    #
    #     &#34;&#34;&#34;
    #
    #     if not callback:
    #         if self.shutdown_on_exception:
    #             self.shutdown()
    #         raise RuntimeError(&#39;set_pin_mode_dht: A Callback must be specified&#39;)
    #
    #     if self.dht_count &lt; PrivateConstants.MAX_DHTS - 1:
    #         self.dht_callbacks[pin] = callback
    #         self.dht_count += 1
    #
    #         command = [PrivateConstants.DHT_NEW, pin]
    #         self._send_command(command)
    #     else:
    #         if self.shutdown_on_exception:
    #             self.shutdown()
    #         raise RuntimeError(
    #             f&#39;Maximum Number Of DHTs Exceeded - set_pin_mode_dht fails for pin {pin}&#39;)
    #
    # # TBD
    # # noinspection PyRedundantParentheses
    # def set_pin_mode_servo(self, pin_number, min_pulse=544, max_pulse=2400):
    #     &#34;&#34;&#34;
    #     NOT YET IMPLEMENTED!!!
    #
    #     Attach a pin to a servo motor
    #
    #     :param pin_number: pin
    #
    #     :param min_pulse: minimum pulse width
    #
    #     :param max_pulse: maximum pulse width
    #
    #     &#34;&#34;&#34;
    #     minv = (min_pulse).to_bytes(2, byteorder=&#34;big&#34;)
    #     maxv = (max_pulse).to_bytes(2, byteorder=&#34;big&#34;)
    #
    #     command = [PrivateConstants.SERVO_ATTACH, pin_number,
    #                minv[0], minv[1], maxv[0], maxv[1]]
    #     self._send_command(command)
    #
    # # TBD
    # def set_pin_mode_sonar(self, trigger_pin, echo_pin,
    #                        callback=None):
    #     &#34;&#34;&#34;
    #     NOT YET IMPLEMENTED!!!
    #
    #     :param trigger_pin:
    #
    #     :param echo_pin:
    #
    #     :param callback: callback
    #
    #     callback data: [PrivateConstants.SONAR_DISTANCE, trigger_pin, distance_value, time_stamp]
    #
    #     &#34;&#34;&#34;
    #
    #     if not callback:
    #         if self.shutdown_on_exception:
    #             self.shutdown()
    #         raise RuntimeError(&#39;set_pin_mode_sonar: A Callback must be specified&#39;)
    #
    #     if self.sonar_count &lt; PrivateConstants.MAX_SONARS - 1:
    #         self.sonar_callbacks[trigger_pin] = callback
    #         self.sonar_count += 1
    #
    #         command = [PrivateConstants.SONAR_NEW, trigger_pin, echo_pin]
    #         self._send_command(command)
    #     else:
    #         if self.shutdown_on_exception:
    #             self.shutdown()
    #         raise RuntimeError(
    #

    def get_pico_pins(self):
        &#34;&#34;&#34;
        This method returns the pico_pins dictionary

        Pin Modes MAP:
            DIGITAL_INPUT = 0
            DIGITAL_OUTPUT = 1
            PWM_OUTPUT = 2
            DIGITAL_INPUT_PULLUP = 3
            DIGITAL_INPUT_PULL_DOWN = 4
            ANALOG_INPUT = 5
            I2C = 9
            EO_PIXEL = 10
            AT_MODE_NOT_SET = 255

        :return: pico_pins
        &#34;&#34;&#34;
        return self.pico_pins

    # TBD
    # def servo_write(self, pin_number, angle):
    #     &#34;&#34;&#34;
    #     NOT YET IMPLEMENTED!!!
    #
    #     Set a servo attached to a pin to a given angle.
    #
    #     :param pin_number: pin
    #
    #     :param angle: angle (0-180)
    #
    #     &#34;&#34;&#34;
    #     command = [PrivateConstants.SERVO_WRITE, pin_number, angle]
    #     self._send_command(command)
    #
    # # TBD
    # def servo_detach(self, pin_number):
    #     &#34;&#34;&#34;
    #     NOT YET IMPLEMENTED!!!
    #
    #     Detach a servo for reuse
    #
    #     :param pin_number: attached pin
    #
    #     &#34;&#34;&#34;
    #     command = [PrivateConstants.SERVO_DETACH, pin_number]
    #     self._send_command(command)

    def _set_pin_mode(self, pin_number, pin_state, differential=0, value_range=0,
                      callback=None):

        &#34;&#34;&#34;
        A private method to set the various pin modes.

        :param pin_number: pico pin number

        :param pin_state: INPUT/OUTPUT/ANALOG/PWM/PULLUP

        :param differential: for analog inputs - threshold
                             value to be achieved for report to
                             be generated

        :param value_range: valid value range

        :param callback: A reference to a call back function to be
                         called when pin data value changes

        &#34;&#34;&#34;
        # Map ADC to GPIO pin numbers
        if pin_state == PrivateConstants.AT_ANALOG:
            self.pico_pins[26 + pin_number] = PrivateConstants.AT_ANALOG
        else:
            if pin_number in self.pico_pins:
                self.pico_pins[pin_number] = pin_state
            else:
                raise RuntimeError(&#39;Gpio Pin Number is invalid&#39;)

        if callback:
            if pin_state == PrivateConstants.AT_INPUT:
                self.digital_callbacks[pin_number] = callback
            elif pin_state == PrivateConstants.AT_INPUT_PULLUP:
                self.digital_callbacks[pin_number] = callback
            elif pin_state == PrivateConstants.AT_INPUT_PULL_DOWN:
                self.digital_callbacks[pin_number] = callback
            elif pin_state == PrivateConstants.AT_ANALOG:
                self.analog_callbacks[pin_number] = callback
            else:
                print(&#39;{} {}&#39;.format(&#39;set_pin_mode: callback ignored for &#39;
                                     &#39;pin state:&#39;, pin_state))

        if pin_state == PrivateConstants.AT_INPUT:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_INPUT, 1]

        elif pin_state == PrivateConstants.AT_INPUT_PULLUP:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_INPUT_PULLUP, 1]

        elif pin_state == PrivateConstants.AT_INPUT_PULL_DOWN:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_INPUT_PULL_DOWN, 1]

        elif pin_state == PrivateConstants.AT_OUTPUT:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_OUTPUT]

        elif pin_state == PrivateConstants.AT_ANALOG:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_ANALOG,
                       differential &gt;&gt; 8, differential &amp; 0xff, 1]

        elif pin_state == PrivateConstants.AT_PWM_OUTPUT:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_PWM_OUTPUT, value_range &gt;&gt; 8,
                       value_range &amp; 0xff]

        else:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;Unknown pin state&#39;)

        if pin_state == PrivateConstants.AT_ANALOG:
            if pin_number == 0:
                self.pico_pins[26] = PrivateConstants.AT_ANALOG
            elif pin_number == 1:
                self.pico_pins[27] = PrivateConstants.AT_ANALOG
            elif pin_number == 13:
                self.pico_pins[28] = PrivateConstants.AT_ANALOG

        else:
            self.pico_pins[pin_number] = pin_state

        if command:
            self._send_command(command)

    def shutdown(self):
        &#34;&#34;&#34;
        This method attempts an orderly shutdown
        If any exceptions are thrown, they are ignored.
        &#34;&#34;&#34;
        self.shutdown_flag = True

        self._stop_threads()

        # try:
        command = [PrivateConstants.STOP_ALL_REPORTS]
        self._send_command(command)
        time.sleep(.2)
        if self.reset_on_shutdown:
            command = [PrivateConstants.RESET_BOARD]
            self._send_command(command)
            time.sleep(.2)

    &#39;&#39;&#39;
    report message handlers
    &#39;&#39;&#39;

    def _analog_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for analog messages.

        :param data: message data

        &#34;&#34;&#34;
        pin = data[0]
        value = (data[1] &lt;&lt; 8) + data[2]
        # set the current value in the pin structure
        time_stamp = time.time()
        # self.digital_pins[pin].event_time = time_stamp
        if self.analog_callbacks[pin]:
            message = [PrivateConstants.ANALOG_REPORT, pin, value, time_stamp]
            self.analog_callbacks[pin](message)

    # TBD
    def _dht_report(self, data):
        &#34;&#34;&#34;
        This is the dht report handler method.

        :param data:            data[0] = report sub type - DHT_DATA or DHT_ERROR

                                data[1] = pin number

                                data[2] = humidity high order byte or error value if DHT_ERROR

                                data[3] = humidity byte 2

                                data[4] = humidity byte 3

                                data[5] = humidity byte 4

                                data[6] = temperature high order byte for data

                                data[7] = temperature byte 2

                                data[8] = temperature byte 3

                                data[9] = temperature byte 4
        &#34;&#34;&#34;

        if data[0]:  # DHT_ERROR
            # error report
            # data[0] = report sub type, data[1] = pin, data[2] = error message
            if self.dht_callbacks[data[1]]:
                # Callback 0=DHT REPORT, DHT_ERROR=0, PIN, Error Number, Time
                message = [PrivateConstants.DHT_REPORT, data[0], data[1], data[2],
                           time.time()]
                self.dht_callbacks[data[1]](message)
        else:
            # got valid data DHT_DATA
            f_humidity = bytearray(data[2:6])
            f_temperature = bytearray(data[6:])
            message = [PrivateConstants.DHT_REPORT, data[0], data[1],
                       (struct.unpack(&#39;&lt;f&#39;, f_humidity))[0],
                       (struct.unpack(&#39;&lt;f&#39;, f_temperature))[0],
                       time.time()]

            self.dht_callbacks[data[1]](message)

    def _digital_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for Digital Messages.

        :param data: digital message

        &#34;&#34;&#34;
        pin = data[0]
        value = data[1]

        time_stamp = time.time()
        if self.digital_callbacks[pin]:
            message = [PrivateConstants.DIGITAL_REPORT, pin, value, time_stamp]
            self.digital_callbacks[pin](message)

    def _firmware_message(self, data):
        &#34;&#34;&#34;
        Telemetrix4pico firmware version message
        :param data: data[0] = major number, data[1] = minor number
        &#34;&#34;&#34;

        self.firmware_version = [data[0], data[1]]

    # TBD
    def _i2c_read_report(self, data):
        &#34;&#34;&#34;
        Execute callback for i2c reads.

        :param data: [I2C_READ_REPORT, i2c_port, i2c_address,
        register, number of bytes read, bytes read..., time-stamp]
        &#34;&#34;&#34;

        cb_list = [PrivateConstants.I2C_READ_REPORT, data[0], data[1]] + data[2:]

        cb_list.append(time.time())

        if cb_list[1]:
            self.i2c_callback2(cb_list)
        else:
            self.i2c_callback(cb_list)

    def _i2c_write_failed(self, data):
        &#34;&#34;&#34;
        I2c write attempt failed

        :param data: data[0] = i2c_device
        &#34;&#34;&#34;
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(
            f&#39;i2c Write Failed for I2C port {data[0]}&#39;)
        while True:
            time.sleep(1)

    def _i2c_read_failed(self, data):
        &#34;&#34;&#34;
        I2c read failed

        :param data: data[0] = i2c device
        &#34;&#34;&#34;
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(
            f&#39;i2c Read Failed for I2C port {data[0]}&#39;)
        while True:
            time.sleep(.1)

    def _report_unique_id(self, data):
        &#34;&#34;&#34;
        Reply to are_u_there message
        :param data: pico id
        &#34;&#34;&#34;

        for i in range(len(data)):
            self.reported_pico_id.append(data[i])

    def _report_debug_data(self, data):
        &#34;&#34;&#34;
        Print debug data sent from pico
        :param data: data[0] is a byte followed by 2
                     bytes that comprise an integer
        :return:
        &#34;&#34;&#34;
        value = (data[1] &lt;&lt; 8) + data[2]
        print(f&#39;DEBUG ID: {data[0]} Value: {value}&#39;)

    def _report_loop_data(self, data):
        &#34;&#34;&#34;
        Print data that was looped back
        :param data: byte of loop back data
        :return:
        &#34;&#34;&#34;
        if self.loop_back_callback:
            self.loop_back_callback(data)

    def _send_command(self, command):
        &#34;&#34;&#34;
        This is a private utility method.


        :param command:  command data in the form of a list

        &#34;&#34;&#34;
        # the length of the list is added at the head
        command.insert(0, len(command))
        # print(command)
        send_message = bytes(command)

        if self.serial_port:
            try:
                self.serial_port.write(send_message)
            except SerialException:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(&#39;write fail in _send_command&#39;)

    # TBD
    def _servo_unavailable(self, report):
        &#34;&#34;&#34;
        Message if no servos are available for use.
        :param report: pin number
        &#34;&#34;&#34;
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(
            f&#39;Servo Attach For Pin {report[0]} Failed: No Available Servos&#39;)

    # TBD
    def _sonar_distance_report(self, report):
        &#34;&#34;&#34;

        :param report: data[0] = trigger pin, data[1] and data[2] = distance

        callback report format: [PrivateConstants.SONAR_DISTANCE, trigger_pin, distance_value, time_stamp]
        &#34;&#34;&#34;

        # get callback from pin number
        cb = self.sonar_callbacks[report[0]]

        # build report data
        cb_list = [PrivateConstants.SONAR_DISTANCE, report[0],
                   ((report[1] &lt;&lt; 8) + report[2]), time.time()]

        cb(cb_list)

    def _run_threads(self):
        self.run_event.set()

    def _is_running(self):
        return self.run_event.is_set()

    def _stop_threads(self):
        self.run_event.clear()

    def _reporter(self):
        &#34;&#34;&#34;
        This is the reporter thread. It continuously pulls data from
        the deque. When a full message is detected, that message is
        processed.
        &#34;&#34;&#34;
        self.run_event.wait()

        while self._is_running() and not self.shutdown_flag:
            if len(self.the_deque):
                # response_data will be populated with the received data for the report
                response_data = []
                packet_length = self.the_deque.popleft()

                if packet_length:
                    # get all the data for the report and place it into response_data
                    for i in range(packet_length):
                        while not len(self.the_deque):
                            time.sleep(self.sleep_tune)
                        data = self.the_deque.popleft()
                        response_data.append(data)

                    # get the report type and look up its dispatch method
                    # here we pop the report type off of response_data
                    report_type = response_data.pop(0)

                    # retrieve the report handler from the dispatch table
                    dispatch_entry = self.report_dispatch.get(report_type)

                    # if there is additional data for the report,
                    # it will be contained in response_data
                    # noinspection PyArgumentList
                    dispatch_entry(response_data)
                    continue

                else:
                    if self.shutdown_on_exception:
                        self.shutdown()
                    raise RuntimeError(
                        &#39;A report with a packet length of zero was received.&#39;)
            else:
                time.sleep(self.sleep_tune)

    def _serial_receiver(self):
        &#34;&#34;&#34;
        Thread to continuously check for incoming data.
        When a byte comes in, place it onto the deque.
        &#34;&#34;&#34;
        self.run_event.wait()

        while self._is_running() and not self.shutdown_flag:
            # we can get an OSError: [Errno9] Bad file descriptor when shutting down
            # just ignore it
            try:
                if self.serial_port.inWaiting():
                    c = self.serial_port.read()
                    self.the_deque.append(ord(c))
                else:
                    time.sleep(self.sleep_tune)
                    # continue
            except OSError:
                pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico"><code class="flex name class">
<span>class <span class="ident">TelemetrixRpiPico</span></span>
<span>(</span><span>com_port=None, pico_instance_id=None, sleep_tune=1e-06, shutdown_on_exception=True, reset_on_shutdown=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This class exposes and implements a Telemetrix type
API for the Raspberry Pi Pico.
It uses threading to accommodate concurrency.
It includes the public API methods as well as
a set of private methods.</p>
<p>:param com_port: e.g. COM3 or /dev/ttyACM0.
Only use if you wish to bypass auto com port
detection.</p>
<p>:param pico_instance_id: If not specified, than don't do id check.
Else contains a board' s pico unique ID.
This is passed as an array.</p>
<p>:param sleep_tune: A tuning parameter (typically not changed by user)</p>
<p>:param shutdown_on_exception: call shutdown before raising
a RunTimeError exception, or
receiving a KeyboardInterrupt exception</p>
<p>:para reset_on_shutdown: Reset the board upon shutdown</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TelemetrixRpiPico(threading.Thread):
    &#34;&#34;&#34;
    This class exposes and implements a Telemetrix type
    API for the Raspberry Pi Pico.
    It uses threading to accommodate concurrency.
    It includes the public API methods as well as
    a set of private methods.

    &#34;&#34;&#34;

    def __init__(self, com_port=None, pico_instance_id=None,
                 sleep_tune=0.000001,
                 shutdown_on_exception=True,
                 reset_on_shutdown=True):

        &#34;&#34;&#34;

        :param com_port: e.g. COM3 or /dev/ttyACM0.
                         Only use if you wish to bypass auto com port
                         detection.

        :param pico_instance_id: If not specified, than don&#39;t do id check.
                                 Else contains a board&#39; s pico unique ID.
                                 This is passed as an array.

        :param sleep_tune: A tuning parameter (typically not changed by user)

        :param shutdown_on_exception: call shutdown before raising
                                      a RunTimeError exception, or
                                      receiving a KeyboardInterrupt exception

        :para reset_on_shutdown: Reset the board upon shutdown
        &#34;&#34;&#34;

        # initialize threading parent
        threading.Thread.__init__(self)

        # create the threads and set them as daemons so
        # that they stop when the program is closed

        # create a thread to interpret received serial data
        self.the_reporter_thread = threading.Thread(target=self._reporter)
        self.the_reporter_thread.daemon = True

        self.the_data_receive_thread = threading.Thread(target=self._serial_receiver)

        # flag to allow the reporter and receive threads to run.
        self.run_event = threading.Event()

        # check to make sure that Python interpreter is version 3.7 or greater
        python_version = sys.version_info
        if python_version[0] &gt;= 3:
            if python_version[1] &gt;= 7:
                pass
            else:
                raise RuntimeError(&#34;ERROR: Python 3.7 or greater is &#34;
                                   &#34;required for use of this program.&#34;)

        # save input parameters as instance variables
        self.com_port = com_port
        self.pico_instance_id = pico_instance_id
        self.sleep_tune = sleep_tune
        self.shutdown_on_exception = shutdown_on_exception
        self.reset_on_shutdown = reset_on_shutdown

        # create a deque to receive and process data from the pico
        self.the_deque = deque()

        # The report_dispatch dictionary is used to process
        # incoming report messages by looking up the report message
        # and executing its associated processing method.

        self.report_dispatch = {}

        # To add a command to the command dispatch table, append here.
        self.report_dispatch.update(
            {PrivateConstants.LOOP_COMMAND: self._report_loop_data})
        self.report_dispatch.update(
            {PrivateConstants.DEBUG_PRINT: self._report_debug_data})
        self.report_dispatch.update(
            {PrivateConstants.DIGITAL_REPORT: self._digital_message})
        self.report_dispatch.update(
            {PrivateConstants.ANALOG_REPORT: self._analog_message})
        self.report_dispatch.update(
            {PrivateConstants.FIRMWARE_REPORT: self._firmware_message})
        self.report_dispatch.update(
            {PrivateConstants.UNIQUE_ID_REPORT: self._report_unique_id})
        self.report_dispatch.update(
            {PrivateConstants.SERVO_UNAVAILABLE: self._servo_unavailable})
        self.report_dispatch.update(
            {PrivateConstants.I2C_READ_REPORT: self._i2c_read_report})
        self.report_dispatch.update(
            {PrivateConstants.I2C_WRITE_FAILED: self._i2c_write_failed})
        self.report_dispatch.update(
            {PrivateConstants.I2C_READ_FAILED: self._i2c_read_failed})
        self.report_dispatch.update(
            {PrivateConstants.SONAR_DISTANCE: self._sonar_distance_report})
        self.report_dispatch.update({PrivateConstants.DHT_REPORT: self._dht_report})

        # up to 16 pwm pins may be simultaneously active
        self.pwm_active_count = 0

        # dictionaries to store the callbacks for each pin
        self.analog_callbacks = {}

        self.digital_callbacks = {}

        self.i2c_callback = None
        self.i2c_callback2 = None

        self.i2c_0_active = False
        self.i2c_1_active = False

        # the trigger pin will be the key to retrieve
        # the callback for a specific HC-SR04
        self.sonar_callbacks = {}

        self.sonar_count = 0

        self.dht_callbacks = {}

        self.dht_count = 0

        # serial port in use
        self.serial_port = None

        # flag to indicate we are in shutdown mode
        self.shutdown_flag = False

        # debug loopback callback method
        self.loop_back_callback = None

        # flag to indicate the start of a new report
        # self.new_report_start = True

        # firmware version to be stored here
        self.firmware_version = []

        # reported pico_id
        self.reported_pico_id = []

        # flag to indicate if i2c was previously enabled
        self.i2c_enabled = False

        # Create a dictionary to store the pins in use.
        # Notice that gpio pins 23, 24 and 25 are not included
        # because the Pico does not support these GPIOs.

        # This dictionary is a list of gpio pins updated with the pin mode when a pin mode
        # is set.
        # It is created initially using a dictionary comprehension.
        self.pico_pins = {gpio_pin: PrivateConstants.AT_MODE_NOT_SET for gpio_pin in
                          range(23)}

        for pin in range(25, 29):
            self.pico_pins[pin] = PrivateConstants.AT_MODE_NOT_SET

        # creating a list of available sda and scl pins for i2c. If assigned the pins
        # value will be set to either 0 or 1 depending upon the i2c selected.
        self.i2c_sda_pins = {n: 255 for n in range(2, 21, 2)}
        self.i2c_sda_pins[26] = 255

        self.i2c_scl_pins = {n: 255 for n in range(3, 22, 2)}
        self.i2c_scl_pins[27] = 255

        self.the_reporter_thread.start()
        self.the_data_receive_thread.start()

        # neopixel data
        self.number_of_pixels = None

        self.neopixels_initiated = False

        print(f&#34;TelemetrixRpiPico:  Version {PrivateConstants.TELEMETRIX_VERSION}\n\n&#34;
              f&#34;Copyright (c) 2020 Alan Yorinks All Rights Reserved.\n&#34;)

        # using the serial link

        if not self.com_port:
            # user did not specify a com_port
            try:
                self._find_pico()
            except KeyboardInterrupt:
                if self.shutdown_on_exception:
                    self.shutdown()
        else:
            # com_port specified - set com_port and baud rate
            try:
                self._manual_open()
            except KeyboardInterrupt:
                if self.shutdown_on_exception:
                    self.shutdown()

        if self.serial_port:
            print(
                f&#34;Serial compatible device found and connected to&#34;
                f&#34; {self.serial_port.port}&#34;)

            self.serial_port.reset_input_buffer()
            self.serial_port.reset_output_buffer()

        # no com_port found - raise a runtime exception
        else:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;No pico Found or User Aborted Program&#39;)

        # allow the threads to run
        self._run_threads()

        print(&#39;Retrieving pico ID...&#39;)
        self._get_pico_id()
        # time.sleep(.2)
        print(f&#39;Pico Unique ID: {self.reported_pico_id}&#39;)

        if self.pico_instance_id:
            if self.reported_pico_id != self.pico_instance_id:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(f&#39;Incorrect pico ID: {self.reported_pico_id}&#39;)
            else:
                print(&#39;Valid pico ID Found.&#39;)
        # get pico firmware version and print it
        print(&#39;\nRetrieving Telemetrix4pico firmware ID...&#39;)
        self._get_firmware_version()
        # time.sleep(.3)
        if not self.firmware_version:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(f&#39;Telemetrix4pico firmware version&#39;)

        else:
            print(f&#39;Telemetrix4pico firmware version: {self.firmware_version[0]}.&#39;
                  f&#39;{self.firmware_version[1]}&#39;)
        command = [PrivateConstants.ENABLE_ALL_REPORTS]
        self._send_command(command)

        # Have the server reset its data structures
        command = [PrivateConstants.RESET_DATA]
        self._send_command(command)

    def _find_pico(self):
        &#34;&#34;&#34;
        This method will search all potential serial ports for a pico
        board using its USB PID and VID.
        &#34;&#34;&#34;

        # a list of serial ports to be checked
        serial_ports = []

        print(&#39;Opening all potential serial ports...&#39;)
        the_ports_list = list_ports.comports()
        for port in the_ports_list:
            if port.pid is None:
                continue
            if port.pid != 10 or port.vid != 11914:
                continue
            try:
                self.serial_port = serial.Serial(port.device, 115200,
                                                 timeout=1, writeTimeout=0)
            except SerialException:
                continue
            # create a list of serial ports that we opened
            # make sure this is a pico board
            if port.pid == 10 and port.vid == 11914:
                serial_ports.append(self.serial_port)

                # display to the user
                print(&#39;\t&#39; + port.device)

                # clear out the serial buffers
                self.serial_port.reset_input_buffer()
                self.serial_port.reset_output_buffer()

    def _manual_open(self):
        &#34;&#34;&#34;
        Com port was specified by the user - try to open up that port

        &#34;&#34;&#34;
        # if port is not found, a serial exception will be thrown
        try:
            print(f&#39;Opening {self.com_port}...&#39;)
            self.serial_port = serial.Serial(self.com_port, 115200,
                                             timeout=1, writeTimeout=0)

            self._run_threads()
            # time.sleep(self.pico_wait)

            self._get_pico_id()
            if self.pico_instance_id:
                if self.reported_pico_id != self.pico_instance_id:
                    if self.shutdown_on_exception:
                        self.shutdown()
                    raise RuntimeError(f&#39;Incorrect pico ID: {self.reported_pico_id}&#39;)
            print(&#39;Valid pico ID Found.&#39;)
            # get pico firmware version and print it
            print(&#39;\nRetrieving Telemetrix4pico firmware ID...&#39;)
            self._get_firmware_version()

            if not self.firmware_version:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(f&#39;Telemetrix4pico Sketch Firmware Version Not Found&#39;)

            else:
                print(f&#39;Telemetrix4pico firmware version: {self.firmware_version[0]}.&#39;
                      f&#39;{self.firmware_version[1]}&#39;)
        except KeyboardInterrupt:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;User Hit Control-C&#39;)

    def pwm_write(self, pin, value):
        &#34;&#34;&#34;
        Set the specified pin to the specified value.

        :param pin: pico GPIO pin number

        :param value: pin value - size is determined by what was set for value_range
        when set_pin_mode_pwm_output was called.

        &#34;&#34;&#34;
        if self.pico_pins[pin] != PrivateConstants.AT_PWM_OUTPUT:
            raise RuntimeError(&#39;pwm_write: You must set the pin mode before performing &#39;
                               &#39;a PWM write.&#39;)
        value_msb = value &gt;&gt; 8
        value_lsb = value &amp; 0xff
        command = [PrivateConstants.PWM_WRITE, pin, value_msb, value_lsb]
        self._send_command(command)

    def digital_write(self, pin, value):
        &#34;&#34;&#34;
        Set the specified pin to the specified value.

        :param pin: pico GPIO pin number

        :param value: pin value (1 or 0)

        &#34;&#34;&#34;
        if self.pico_pins[pin] != PrivateConstants.AT_OUTPUT:
            raise RuntimeError(&#39;pwm_write: You must set the pin mode before performing &#39;
                               &#39;a digital write.&#39;)
        command = [PrivateConstants.DIGITAL_WRITE, pin, value]
        self._send_command(command)

    def disable_all_reporting(self):
        &#34;&#34;&#34;
        Disable reporting for all digital and analog input pins
        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_DISABLE_ALL, 0]
        self._send_command(command)

    def disable_analog_reporting(self, pin):
        &#34;&#34;&#34;
        Disables analog reporting for a single analog pin.

        :param pin: Analog pin number. For example for ADC, the number is 0.

        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_ANALOG_DISABLE, pin]
        self._send_command(command)

    def disable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Disables digital reporting for a single digital input.

        :param pin: GPIO Pin number.

        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_DIGITAL_DISABLE, pin]
        self._send_command(command)

    def enable_analog_reporting(self, pin):
        &#34;&#34;&#34;
        Enables analog reporting for the specified pin.

        :param pin: Analog pin number. For example for ADC0, the number is 0.


        &#34;&#34;&#34;
        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_ANALOG_ENABLE, pin]
        self._send_command(command)

    def enable_digital_reporting(self, pin):
        &#34;&#34;&#34;
        Enable reporting on the specified digital pin.

        :param pin: GPIO Pin number.
        &#34;&#34;&#34;

        command = [PrivateConstants.MODIFY_REPORTING,
                   PrivateConstants.REPORTING_DIGITAL_ENABLE, pin]
        self._send_command(command)

    def _get_pico_id(self):
        &#34;&#34;&#34;
        Retrieve pico-telemetrix pico id

        &#34;&#34;&#34;
        command = [PrivateConstants.RETRIEVE_PICO_UNIQUE_ID]
        self._send_command(command)
        # provide time for the reply
        time.sleep(.5)

    def _get_firmware_version(self):
        &#34;&#34;&#34;
        This method retrieves the
        pico-telemetrix firmware version

        &#34;&#34;&#34;
        command = [PrivateConstants.GET_FIRMWARE_VERSION]
        self._send_command(command)
        # provide time for the reply
        time.sleep(.5)

    # TBD
    def i2c_read(self, address, register, number_of_bytes,
                 callback=None, i2c_port=0, no_stop=False):
        &#34;&#34;&#34;
        Read the specified number of bytes from the specified register for
        the i2c device.


        :param address: i2c device address

        :param register: i2c register (or None if no register selection is needed)

        :param number_of_bytes: number of bytes to be read

        :param callback: Required callback function to report i2c data as a
                   result of read command

       :param i2c_port: 0 = port 0, 1 = port 1

       :param no_stop: If true, master retains control of the bus at the end of the
                       transfer (no Stop is issued), and the next transfer will
                       begin with a Restart rather than a Start.


        callback returns a data list:
        [I2C_READ_REPORT, i2c_port, i2c_device_address, count of data bytes, data bytes,
        time-stamp]

        I2C_READ_REPORT = 10

        &#34;&#34;&#34;

        if not callback:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;I2C Read: A callback function must be specified.&#39;)

        # i2c_port = 0 for port 0
        if i2c_port == 0:
            if not self.i2c_0_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Write: set_pin_mode_i2c never called for i2c port 0.&#39;)
            else:
                self.i2c_callback = callback

        else:
            if not i2c_port == 1:
                if not self.i2c_0_active:
                    if self.shutdown_on_exception:
                        self.shutdown()
                    raise RuntimeError(
                        &#39;I2C Write: set_pin_mode_i2c never called for i2c port 1.&#39;)
                else:
                    self.i2c_callback2 = callback

        command = [PrivateConstants.I2C_READ, i2c_port, address, register,
                   number_of_bytes, no_stop]

        # no register specified
        if not register:
            command[3] = PrivateConstants.I2C_NO_REGISTER

        self._send_command(command)

    # TBD
    def i2c_write(self, address, args, i2c_port=0, no_stop=False):
        &#34;&#34;&#34;
        Write data to an i2c device.

        :param address: i2c device address

        :param args: A variable number of bytes to be sent to the device
                     passed in as a list.
                     NOTE: THIS MUST BE IN THE FORM OF A LIST.

        :param i2c_port: 0= port 0, 1 = port 1

        :param no_stop: If true, master retains control of the bus at the end of the
                       transfer (no Stop is issued), and the next transfer will
                       begin with a Restart rather than a Start.



        &#34;&#34;&#34;
        if not i2c_port:
            if not self.i2c_0_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Write: set_pin_mode i2c never called for i2c port 0.&#39;)

        elif i2c_port:
            if not self.i2c_1_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Write: set_pin_mode i2c never called for i2c port 2.&#39;)

        command = [PrivateConstants.I2C_WRITE, i2c_port, address, len(args), no_stop]

        for item in args:
            command.append(item)

        self._send_command(command)

    def neo_pixel_set_value(self, pixel_number, r=0, g=0, b=0, auto_show=False):
        &#34;&#34;&#34;
        Set the selected pixel in the pixel array on the Pico to
        the value provided.

        :param pixel_number: pixel number

        :param r: red value 0-255

        :param g: green value 0-255

        :param b: blue value 0-255

        :param auto_show: call show automatically

        &#34;&#34;&#34;
        if not self.neopixels_initiated:
            raise RuntimeError(&#39;You must call set_pin_mode_neopixel first&#39;)

        if pixel_number &gt; self.number_of_pixels:
            raise RuntimeError(&#39;Pixel number is out of legal range&#39;)

        if r and g and b not in range(256):
            raise RuntimeError(&#39;Pixel value must be in the range of 0-255&#39;)

        command = [PrivateConstants.SET_NEO_PIXEL, pixel_number, r, g, b, auto_show]
        self._send_command(command)

        if auto_show:
            self.neopixel_show()

    def neopixel_clear(self, auto_show=True):
        &#34;&#34;&#34;
        Clear all pixels

        :param auto_show: call show automatically

        &#34;&#34;&#34;
        if not self.neopixels_initiated:
            raise RuntimeError(&#39;You must call set_pin_mode_neopixel first&#39;)
        command = [PrivateConstants.CLEAR_ALL_NEO_PIXELS, auto_show]
        self._send_command(command)
        if auto_show:
            self.neopixel_show()

    def neopixel_fill(self, r=0, g=0, b=0, auto_show=True):
        &#34;&#34;&#34;
        Fill all pixels with specified value

        :param r: 0-255

        :param g: 0-255

        :param b: 0-255

        :param auto_show: call show automatically
        &#34;&#34;&#34;
        if not self.neopixels_initiated:
            raise RuntimeError(&#39;You must call set_pin_mode_neopixel first&#39;)
        if r and g and b not in range(256):
            raise RuntimeError(&#39;Pixel value must be in the range of 0-255&#39;)
        command = [PrivateConstants.FILL_ALL_NEO_PIXELS, r, g, b, auto_show]
        self._send_command(command)

        if auto_show:
            self.neopixel_show()

    def neopixel_show(self):
        &#34;&#34;&#34;
        Write the NeoPixel buffer stored in the Pico to the NeoPixel strip.

        &#34;&#34;&#34;
        if not self.neopixels_initiated:
            raise RuntimeError(&#39;You must call set_pin_mode_neopixel first&#39;)
        command = [PrivateConstants.SHOW_NEO_PIXELS]
        self._send_command(command)

    def loop_back(self, start_character, callback=None):
        &#34;&#34;&#34;
        This is a debugging method to send a character to the
        pico device, and have the device loop it back.

        :param start_character: The character to loop back. It should be
                                an integer.

        :param callback: Looped back character will appear in the callback method

        &#34;&#34;&#34;
        command = [PrivateConstants.LOOP_COMMAND, ord(start_character)]
        self.loop_back_callback = callback
        self._send_command(command)

    def set_pin_mode_analog_input(self, adc_number, differential=0, callback=None):
        &#34;&#34;&#34;
        Set a pin as an analog input.

        :param adc_number: ADC Number 0-3 - ADC 3 is the temp sensor

        :param differential: difference in previous to current value before
                             report will be generated

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for analog input pins = 3

        &#34;&#34;&#34;
        # make sure adc number is in range
        if not 0 &lt; adc_number &lt; 5:
            raise RuntimeError(&#39;Invalid ADC Number&#39;)
        self._set_pin_mode(adc_number, PrivateConstants.AT_ANALOG, differential,
                           callback=callback)

    def set_pin_mode_digital_input(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input.

        :param pin_number: pico GPIO pin number

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins = 2

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT, callback=callback)

    def set_pin_mode_digital_input_pullup(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input with pullup enabled.

        :param pin_number: pico GPIO pin number

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins with pullups enabled = 2

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT_PULLUP,
                           callback=callback)

    def set_pin_mode_digital_input_pull_down(self, pin_number, callback=None):
        &#34;&#34;&#34;
        Set a pin as a digital input with pull down enabled.

        :param pin_number: pico GPIO pin number

        :param callback: callback function


        callback returns a data list:

        [pin_type, pin_number, pin_value, raw_time_stamp]

        The pin_type for digital input pins with pullups enabled = 2

        &#34;&#34;&#34;
        self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT_PULL_DOWN,
                           callback=callback)

    def set_pin_mode_digital_output(self, pin_number):
        &#34;&#34;&#34;
        Set a pin as a digital output pin.

        :param pin_number: pico GPIO pin number
        &#34;&#34;&#34;

        self._set_pin_mode(pin_number, PrivateConstants.AT_OUTPUT)

    def set_pin_mode_neopixel(self, pin_number=28, num_pixels=8,
                              fill_r=0, fill_g=0, fill_b=0):
        &#34;&#34;&#34;
        Initialize the pico for NeoPixel control. Fill with rgb values specified.

        Default: Set all the pixels to off.

        :param pin_number: neopixel GPIO control pin

        :param num_pixels: number of pixels in the strip

        :param fill_r: initial red fill value 0-255

        :param fill_g: initial green fill value 0-255

        :param fill_b: initial blue fill value 0-255


        &#34;&#34;&#34;
        if fill_r or fill_g or fill_g not in range(256):
            raise RuntimeError(&#39;Pixel value must be in the range of 0-255&#39;)

        self.number_of_pixels = num_pixels

        command = [PrivateConstants.INITIALIZE_NEO_PIXELS, pin_number,
                   self.number_of_pixels, fill_r, fill_g, fill_b]

        self._send_command(command)

        self.pico_pins[pin_number] = PrivateConstants.AT_NEO_PIXEL

        self.neopixels_initiated = True

    def set_pin_mode_pwm_output(self, pin_number, value_range=255):
        &#34;&#34;&#34;
        Enable a pin as a PWM pin. Maximum number of PWMs is 16.

        :param pin_number: pico GPIO pin number

        :param value_range: value range - 16 bits
        &#34;&#34;&#34;

        if pin_number in self.pico_pins:
            self.pico_pins[pin_number] = PrivateConstants.AT_PWM_OUTPUT
            if self.pwm_active_count &gt;= 15:
                raise RuntimeError(
                    &#39;set_pin_mode_pwm_output: number of active PWM pins is at maximum&#39;)

            if value_range &gt; 0xffff:
                raise RuntimeError(
                    &#39;set_pin_mode_pwm_output: value_range is limited to 16 bits&#39;)

            self.pwm_active_count += 1

            self._set_pin_mode(pin_number, PrivateConstants.AT_PWM_OUTPUT,
                               value_range=value_range)
        else:
            raise RuntimeError(&#39;Gpio Pin Number is invalid&#39;)

    # TBD
    def set_pin_mode_i2c(self, i2c_port=0, sda_gpio=4, scl_gpio=5):
        &#34;&#34;&#34;
        Establish the standard pico i2c pins for i2c utilization.

        :param i2c_port: 0 = i2c0, 1 = i2c1

        :param sda_gpio: gpio pin assigned to SDA

        :param scl_gpio: gpio pin assigned to SCL


        NOTES:
               1. THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE &lt;br&gt;
               2. Callbacks are set within the individual i2c read methods of this
              API.

              See i2c_read, and i2c_write

        &#34;&#34;&#34;
        # determine if the i2c port is specified correctly
        if i2c_port not in [0, 1]:
            raise RuntimeError(&#39;i2c port must be either a 0 or 1&#39;)
        # determine if the sda and scl gpio&#39;s are valid
        if sda_gpio not in self.i2c_sda_pins:
            raise RuntimeError(f&#39;GPIO {sda_gpio} is an invalid i2c SDA GPIO&#39;)
        if scl_gpio not in self.i2c_scl_pins:
            raise RuntimeError(f&#39;GPIO {scl_gpio} is an invalid i2c SCL GPIO&#39;)

        # are both GPIOs available?
        if not self.i2c_sda_pins[sda_gpio] == 255:
            raise RuntimeError(f&#39;GPIO SDA pin {sda_gpio} is already in use.&#39;)
        if not self.i2c_scl_pins[scl_gpio] == 255:
            raise RuntimeError(f&#39;GPIO SCL pin {scl_gpio} is already in use.&#39;)
        # both pins available - mark the sda and scl dictionaries appropriately
        self.i2c_sda_pins[sda_gpio] = self.i2c_scl_pins[scl_gpio] = i2c_port

        # now mark the pico_pins dictionary for these pins
        self.pico_pins[sda_gpio] = self.pico_pins[scl_gpio] = PrivateConstants.AT_I2C

        # determine if the specified sda or scl pin has already been
        # assigned.

        # test for i2c port 0
        if not i2c_port:
            self.i2c_0_active = True
        # port 1
        else:
            self.i2c_1_active = True

        command = [PrivateConstants.I2C_BEGIN, i2c_port, sda_gpio, scl_gpio]
        self._send_command(command)

    # TBD
    # def set_pin_mode_dht(self, pin, callback=None):
    #     &#34;&#34;&#34;
    #     NOT YET IMPLEMENTED!!!
    #
    #     :param pin: connection pin
    #
    #     :param callback: callback function
    #
    #     Error Callback: [Callback 0=DHT REPORT, DHT_ERROR=0, PIN, Error Number, Time]
    #
    #     Valid Data Callback: Callback 0=DHT REPORT, DHT_DATA=1, PIN, Humidity, Temperature Time]
    #
    #     &#34;&#34;&#34;
    #
    #     if not callback:
    #         if self.shutdown_on_exception:
    #             self.shutdown()
    #         raise RuntimeError(&#39;set_pin_mode_dht: A Callback must be specified&#39;)
    #
    #     if self.dht_count &lt; PrivateConstants.MAX_DHTS - 1:
    #         self.dht_callbacks[pin] = callback
    #         self.dht_count += 1
    #
    #         command = [PrivateConstants.DHT_NEW, pin]
    #         self._send_command(command)
    #     else:
    #         if self.shutdown_on_exception:
    #             self.shutdown()
    #         raise RuntimeError(
    #             f&#39;Maximum Number Of DHTs Exceeded - set_pin_mode_dht fails for pin {pin}&#39;)
    #
    # # TBD
    # # noinspection PyRedundantParentheses
    # def set_pin_mode_servo(self, pin_number, min_pulse=544, max_pulse=2400):
    #     &#34;&#34;&#34;
    #     NOT YET IMPLEMENTED!!!
    #
    #     Attach a pin to a servo motor
    #
    #     :param pin_number: pin
    #
    #     :param min_pulse: minimum pulse width
    #
    #     :param max_pulse: maximum pulse width
    #
    #     &#34;&#34;&#34;
    #     minv = (min_pulse).to_bytes(2, byteorder=&#34;big&#34;)
    #     maxv = (max_pulse).to_bytes(2, byteorder=&#34;big&#34;)
    #
    #     command = [PrivateConstants.SERVO_ATTACH, pin_number,
    #                minv[0], minv[1], maxv[0], maxv[1]]
    #     self._send_command(command)
    #
    # # TBD
    # def set_pin_mode_sonar(self, trigger_pin, echo_pin,
    #                        callback=None):
    #     &#34;&#34;&#34;
    #     NOT YET IMPLEMENTED!!!
    #
    #     :param trigger_pin:
    #
    #     :param echo_pin:
    #
    #     :param callback: callback
    #
    #     callback data: [PrivateConstants.SONAR_DISTANCE, trigger_pin, distance_value, time_stamp]
    #
    #     &#34;&#34;&#34;
    #
    #     if not callback:
    #         if self.shutdown_on_exception:
    #             self.shutdown()
    #         raise RuntimeError(&#39;set_pin_mode_sonar: A Callback must be specified&#39;)
    #
    #     if self.sonar_count &lt; PrivateConstants.MAX_SONARS - 1:
    #         self.sonar_callbacks[trigger_pin] = callback
    #         self.sonar_count += 1
    #
    #         command = [PrivateConstants.SONAR_NEW, trigger_pin, echo_pin]
    #         self._send_command(command)
    #     else:
    #         if self.shutdown_on_exception:
    #             self.shutdown()
    #         raise RuntimeError(
    #

    def get_pico_pins(self):
        &#34;&#34;&#34;
        This method returns the pico_pins dictionary

        Pin Modes MAP:
            DIGITAL_INPUT = 0
            DIGITAL_OUTPUT = 1
            PWM_OUTPUT = 2
            DIGITAL_INPUT_PULLUP = 3
            DIGITAL_INPUT_PULL_DOWN = 4
            ANALOG_INPUT = 5
            I2C = 9
            EO_PIXEL = 10
            AT_MODE_NOT_SET = 255

        :return: pico_pins
        &#34;&#34;&#34;
        return self.pico_pins

    # TBD
    # def servo_write(self, pin_number, angle):
    #     &#34;&#34;&#34;
    #     NOT YET IMPLEMENTED!!!
    #
    #     Set a servo attached to a pin to a given angle.
    #
    #     :param pin_number: pin
    #
    #     :param angle: angle (0-180)
    #
    #     &#34;&#34;&#34;
    #     command = [PrivateConstants.SERVO_WRITE, pin_number, angle]
    #     self._send_command(command)
    #
    # # TBD
    # def servo_detach(self, pin_number):
    #     &#34;&#34;&#34;
    #     NOT YET IMPLEMENTED!!!
    #
    #     Detach a servo for reuse
    #
    #     :param pin_number: attached pin
    #
    #     &#34;&#34;&#34;
    #     command = [PrivateConstants.SERVO_DETACH, pin_number]
    #     self._send_command(command)

    def _set_pin_mode(self, pin_number, pin_state, differential=0, value_range=0,
                      callback=None):

        &#34;&#34;&#34;
        A private method to set the various pin modes.

        :param pin_number: pico pin number

        :param pin_state: INPUT/OUTPUT/ANALOG/PWM/PULLUP

        :param differential: for analog inputs - threshold
                             value to be achieved for report to
                             be generated

        :param value_range: valid value range

        :param callback: A reference to a call back function to be
                         called when pin data value changes

        &#34;&#34;&#34;
        # Map ADC to GPIO pin numbers
        if pin_state == PrivateConstants.AT_ANALOG:
            self.pico_pins[26 + pin_number] = PrivateConstants.AT_ANALOG
        else:
            if pin_number in self.pico_pins:
                self.pico_pins[pin_number] = pin_state
            else:
                raise RuntimeError(&#39;Gpio Pin Number is invalid&#39;)

        if callback:
            if pin_state == PrivateConstants.AT_INPUT:
                self.digital_callbacks[pin_number] = callback
            elif pin_state == PrivateConstants.AT_INPUT_PULLUP:
                self.digital_callbacks[pin_number] = callback
            elif pin_state == PrivateConstants.AT_INPUT_PULL_DOWN:
                self.digital_callbacks[pin_number] = callback
            elif pin_state == PrivateConstants.AT_ANALOG:
                self.analog_callbacks[pin_number] = callback
            else:
                print(&#39;{} {}&#39;.format(&#39;set_pin_mode: callback ignored for &#39;
                                     &#39;pin state:&#39;, pin_state))

        if pin_state == PrivateConstants.AT_INPUT:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_INPUT, 1]

        elif pin_state == PrivateConstants.AT_INPUT_PULLUP:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_INPUT_PULLUP, 1]

        elif pin_state == PrivateConstants.AT_INPUT_PULL_DOWN:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_INPUT_PULL_DOWN, 1]

        elif pin_state == PrivateConstants.AT_OUTPUT:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_OUTPUT]

        elif pin_state == PrivateConstants.AT_ANALOG:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_ANALOG,
                       differential &gt;&gt; 8, differential &amp; 0xff, 1]

        elif pin_state == PrivateConstants.AT_PWM_OUTPUT:
            command = [PrivateConstants.SET_PIN_MODE, pin_number,
                       PrivateConstants.AT_PWM_OUTPUT, value_range &gt;&gt; 8,
                       value_range &amp; 0xff]

        else:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(&#39;Unknown pin state&#39;)

        if pin_state == PrivateConstants.AT_ANALOG:
            if pin_number == 0:
                self.pico_pins[26] = PrivateConstants.AT_ANALOG
            elif pin_number == 1:
                self.pico_pins[27] = PrivateConstants.AT_ANALOG
            elif pin_number == 13:
                self.pico_pins[28] = PrivateConstants.AT_ANALOG

        else:
            self.pico_pins[pin_number] = pin_state

        if command:
            self._send_command(command)

    def shutdown(self):
        &#34;&#34;&#34;
        This method attempts an orderly shutdown
        If any exceptions are thrown, they are ignored.
        &#34;&#34;&#34;
        self.shutdown_flag = True

        self._stop_threads()

        # try:
        command = [PrivateConstants.STOP_ALL_REPORTS]
        self._send_command(command)
        time.sleep(.2)
        if self.reset_on_shutdown:
            command = [PrivateConstants.RESET_BOARD]
            self._send_command(command)
            time.sleep(.2)

    &#39;&#39;&#39;
    report message handlers
    &#39;&#39;&#39;

    def _analog_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for analog messages.

        :param data: message data

        &#34;&#34;&#34;
        pin = data[0]
        value = (data[1] &lt;&lt; 8) + data[2]
        # set the current value in the pin structure
        time_stamp = time.time()
        # self.digital_pins[pin].event_time = time_stamp
        if self.analog_callbacks[pin]:
            message = [PrivateConstants.ANALOG_REPORT, pin, value, time_stamp]
            self.analog_callbacks[pin](message)

    # TBD
    def _dht_report(self, data):
        &#34;&#34;&#34;
        This is the dht report handler method.

        :param data:            data[0] = report sub type - DHT_DATA or DHT_ERROR

                                data[1] = pin number

                                data[2] = humidity high order byte or error value if DHT_ERROR

                                data[3] = humidity byte 2

                                data[4] = humidity byte 3

                                data[5] = humidity byte 4

                                data[6] = temperature high order byte for data

                                data[7] = temperature byte 2

                                data[8] = temperature byte 3

                                data[9] = temperature byte 4
        &#34;&#34;&#34;

        if data[0]:  # DHT_ERROR
            # error report
            # data[0] = report sub type, data[1] = pin, data[2] = error message
            if self.dht_callbacks[data[1]]:
                # Callback 0=DHT REPORT, DHT_ERROR=0, PIN, Error Number, Time
                message = [PrivateConstants.DHT_REPORT, data[0], data[1], data[2],
                           time.time()]
                self.dht_callbacks[data[1]](message)
        else:
            # got valid data DHT_DATA
            f_humidity = bytearray(data[2:6])
            f_temperature = bytearray(data[6:])
            message = [PrivateConstants.DHT_REPORT, data[0], data[1],
                       (struct.unpack(&#39;&lt;f&#39;, f_humidity))[0],
                       (struct.unpack(&#39;&lt;f&#39;, f_temperature))[0],
                       time.time()]

            self.dht_callbacks[data[1]](message)

    def _digital_message(self, data):
        &#34;&#34;&#34;
        This is a private message handler method.
        It is a message handler for Digital Messages.

        :param data: digital message

        &#34;&#34;&#34;
        pin = data[0]
        value = data[1]

        time_stamp = time.time()
        if self.digital_callbacks[pin]:
            message = [PrivateConstants.DIGITAL_REPORT, pin, value, time_stamp]
            self.digital_callbacks[pin](message)

    def _firmware_message(self, data):
        &#34;&#34;&#34;
        Telemetrix4pico firmware version message
        :param data: data[0] = major number, data[1] = minor number
        &#34;&#34;&#34;

        self.firmware_version = [data[0], data[1]]

    # TBD
    def _i2c_read_report(self, data):
        &#34;&#34;&#34;
        Execute callback for i2c reads.

        :param data: [I2C_READ_REPORT, i2c_port, i2c_address,
        register, number of bytes read, bytes read..., time-stamp]
        &#34;&#34;&#34;

        cb_list = [PrivateConstants.I2C_READ_REPORT, data[0], data[1]] + data[2:]

        cb_list.append(time.time())

        if cb_list[1]:
            self.i2c_callback2(cb_list)
        else:
            self.i2c_callback(cb_list)

    def _i2c_write_failed(self, data):
        &#34;&#34;&#34;
        I2c write attempt failed

        :param data: data[0] = i2c_device
        &#34;&#34;&#34;
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(
            f&#39;i2c Write Failed for I2C port {data[0]}&#39;)
        while True:
            time.sleep(1)

    def _i2c_read_failed(self, data):
        &#34;&#34;&#34;
        I2c read failed

        :param data: data[0] = i2c device
        &#34;&#34;&#34;
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(
            f&#39;i2c Read Failed for I2C port {data[0]}&#39;)
        while True:
            time.sleep(.1)

    def _report_unique_id(self, data):
        &#34;&#34;&#34;
        Reply to are_u_there message
        :param data: pico id
        &#34;&#34;&#34;

        for i in range(len(data)):
            self.reported_pico_id.append(data[i])

    def _report_debug_data(self, data):
        &#34;&#34;&#34;
        Print debug data sent from pico
        :param data: data[0] is a byte followed by 2
                     bytes that comprise an integer
        :return:
        &#34;&#34;&#34;
        value = (data[1] &lt;&lt; 8) + data[2]
        print(f&#39;DEBUG ID: {data[0]} Value: {value}&#39;)

    def _report_loop_data(self, data):
        &#34;&#34;&#34;
        Print data that was looped back
        :param data: byte of loop back data
        :return:
        &#34;&#34;&#34;
        if self.loop_back_callback:
            self.loop_back_callback(data)

    def _send_command(self, command):
        &#34;&#34;&#34;
        This is a private utility method.


        :param command:  command data in the form of a list

        &#34;&#34;&#34;
        # the length of the list is added at the head
        command.insert(0, len(command))
        # print(command)
        send_message = bytes(command)

        if self.serial_port:
            try:
                self.serial_port.write(send_message)
            except SerialException:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(&#39;write fail in _send_command&#39;)

    # TBD
    def _servo_unavailable(self, report):
        &#34;&#34;&#34;
        Message if no servos are available for use.
        :param report: pin number
        &#34;&#34;&#34;
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(
            f&#39;Servo Attach For Pin {report[0]} Failed: No Available Servos&#39;)

    # TBD
    def _sonar_distance_report(self, report):
        &#34;&#34;&#34;

        :param report: data[0] = trigger pin, data[1] and data[2] = distance

        callback report format: [PrivateConstants.SONAR_DISTANCE, trigger_pin, distance_value, time_stamp]
        &#34;&#34;&#34;

        # get callback from pin number
        cb = self.sonar_callbacks[report[0]]

        # build report data
        cb_list = [PrivateConstants.SONAR_DISTANCE, report[0],
                   ((report[1] &lt;&lt; 8) + report[2]), time.time()]

        cb(cb_list)

    def _run_threads(self):
        self.run_event.set()

    def _is_running(self):
        return self.run_event.is_set()

    def _stop_threads(self):
        self.run_event.clear()

    def _reporter(self):
        &#34;&#34;&#34;
        This is the reporter thread. It continuously pulls data from
        the deque. When a full message is detected, that message is
        processed.
        &#34;&#34;&#34;
        self.run_event.wait()

        while self._is_running() and not self.shutdown_flag:
            if len(self.the_deque):
                # response_data will be populated with the received data for the report
                response_data = []
                packet_length = self.the_deque.popleft()

                if packet_length:
                    # get all the data for the report and place it into response_data
                    for i in range(packet_length):
                        while not len(self.the_deque):
                            time.sleep(self.sleep_tune)
                        data = self.the_deque.popleft()
                        response_data.append(data)

                    # get the report type and look up its dispatch method
                    # here we pop the report type off of response_data
                    report_type = response_data.pop(0)

                    # retrieve the report handler from the dispatch table
                    dispatch_entry = self.report_dispatch.get(report_type)

                    # if there is additional data for the report,
                    # it will be contained in response_data
                    # noinspection PyArgumentList
                    dispatch_entry(response_data)
                    continue

                else:
                    if self.shutdown_on_exception:
                        self.shutdown()
                    raise RuntimeError(
                        &#39;A report with a packet length of zero was received.&#39;)
            else:
                time.sleep(self.sleep_tune)

    def _serial_receiver(self):
        &#34;&#34;&#34;
        Thread to continuously check for incoming data.
        When a byte comes in, place it onto the deque.
        &#34;&#34;&#34;
        self.run_event.wait()

        while self._is_running() and not self.shutdown_flag:
            # we can get an OSError: [Errno9] Bad file descriptor when shutting down
            # just ignore it
            try:
                if self.serial_port.inWaiting():
                    c = self.serial_port.read()
                    self.the_deque.append(ord(c))
                else:
                    time.sleep(self.sleep_tune)
                    # continue
            except OSError:
                pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.digital_write"><code class="name flex">
<span>def <span class="ident">digital_write</span></span>(<span>self, pin, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the specified pin to the specified value.</p>
<p>:param pin: pico GPIO pin number</p>
<p>:param value: pin value (1 or 0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def digital_write(self, pin, value):
    &#34;&#34;&#34;
    Set the specified pin to the specified value.

    :param pin: pico GPIO pin number

    :param value: pin value (1 or 0)

    &#34;&#34;&#34;
    if self.pico_pins[pin] != PrivateConstants.AT_OUTPUT:
        raise RuntimeError(&#39;pwm_write: You must set the pin mode before performing &#39;
                           &#39;a digital write.&#39;)
    command = [PrivateConstants.DIGITAL_WRITE, pin, value]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.disable_all_reporting"><code class="name flex">
<span>def <span class="ident">disable_all_reporting</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable reporting for all digital and analog input pins</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_all_reporting(self):
    &#34;&#34;&#34;
    Disable reporting for all digital and analog input pins
    &#34;&#34;&#34;
    command = [PrivateConstants.MODIFY_REPORTING,
               PrivateConstants.REPORTING_DISABLE_ALL, 0]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.disable_analog_reporting"><code class="name flex">
<span>def <span class="ident">disable_analog_reporting</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables analog reporting for a single analog pin.</p>
<p>:param pin: Analog pin number. For example for ADC, the number is 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_analog_reporting(self, pin):
    &#34;&#34;&#34;
    Disables analog reporting for a single analog pin.

    :param pin: Analog pin number. For example for ADC, the number is 0.

    &#34;&#34;&#34;
    command = [PrivateConstants.MODIFY_REPORTING,
               PrivateConstants.REPORTING_ANALOG_DISABLE, pin]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.disable_digital_reporting"><code class="name flex">
<span>def <span class="ident">disable_digital_reporting</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Disables digital reporting for a single digital input.</p>
<p>:param pin: GPIO Pin number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_digital_reporting(self, pin):
    &#34;&#34;&#34;
    Disables digital reporting for a single digital input.

    :param pin: GPIO Pin number.

    &#34;&#34;&#34;
    command = [PrivateConstants.MODIFY_REPORTING,
               PrivateConstants.REPORTING_DIGITAL_DISABLE, pin]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.enable_analog_reporting"><code class="name flex">
<span>def <span class="ident">enable_analog_reporting</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables analog reporting for the specified pin.</p>
<p>:param pin: Analog pin number. For example for ADC0, the number is 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_analog_reporting(self, pin):
    &#34;&#34;&#34;
    Enables analog reporting for the specified pin.

    :param pin: Analog pin number. For example for ADC0, the number is 0.


    &#34;&#34;&#34;
    command = [PrivateConstants.MODIFY_REPORTING,
               PrivateConstants.REPORTING_ANALOG_ENABLE, pin]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.enable_digital_reporting"><code class="name flex">
<span>def <span class="ident">enable_digital_reporting</span></span>(<span>self, pin)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable reporting on the specified digital pin.</p>
<p>:param pin: GPIO Pin number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_digital_reporting(self, pin):
    &#34;&#34;&#34;
    Enable reporting on the specified digital pin.

    :param pin: GPIO Pin number.
    &#34;&#34;&#34;

    command = [PrivateConstants.MODIFY_REPORTING,
               PrivateConstants.REPORTING_DIGITAL_ENABLE, pin]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.get_pico_pins"><code class="name flex">
<span>def <span class="ident">get_pico_pins</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the pico_pins dictionary</p>
<p>Pin Modes MAP:
DIGITAL_INPUT = 0
DIGITAL_OUTPUT = 1
PWM_OUTPUT = 2
DIGITAL_INPUT_PULLUP = 3
DIGITAL_INPUT_PULL_DOWN = 4
ANALOG_INPUT = 5
I2C = 9
EO_PIXEL = 10
AT_MODE_NOT_SET = 255</p>
<p>:return: pico_pins</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pico_pins(self):
    &#34;&#34;&#34;
    This method returns the pico_pins dictionary

    Pin Modes MAP:
        DIGITAL_INPUT = 0
        DIGITAL_OUTPUT = 1
        PWM_OUTPUT = 2
        DIGITAL_INPUT_PULLUP = 3
        DIGITAL_INPUT_PULL_DOWN = 4
        ANALOG_INPUT = 5
        I2C = 9
        EO_PIXEL = 10
        AT_MODE_NOT_SET = 255

    :return: pico_pins
    &#34;&#34;&#34;
    return self.pico_pins</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.i2c_read"><code class="name flex">
<span>def <span class="ident">i2c_read</span></span>(<span>self, address, register, number_of_bytes, callback=None, i2c_port=0, no_stop=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the specified number of bytes from the specified register for
the i2c device.</p>
<p>:param address: i2c device address</p>
<p>:param register: i2c register (or None if no register selection is needed)</p>
<p>:param number_of_bytes: number of bytes to be read</p>
<p>:param callback: Required callback function to report i2c data as a
result of read command</p>
<p>:param i2c_port: 0 = port 0, 1 = port 1</p>
<p>:param no_stop: If true, master retains control of the bus at the end of the
transfer (no Stop is issued), and the next transfer will
begin with a Restart rather than a Start.</p>
<p>callback returns a data list:
[I2C_READ_REPORT, i2c_port, i2c_device_address, count of data bytes, data bytes,
time-stamp]</p>
<p>I2C_READ_REPORT = 10</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def i2c_read(self, address, register, number_of_bytes,
             callback=None, i2c_port=0, no_stop=False):
    &#34;&#34;&#34;
    Read the specified number of bytes from the specified register for
    the i2c device.


    :param address: i2c device address

    :param register: i2c register (or None if no register selection is needed)

    :param number_of_bytes: number of bytes to be read

    :param callback: Required callback function to report i2c data as a
               result of read command

   :param i2c_port: 0 = port 0, 1 = port 1

   :param no_stop: If true, master retains control of the bus at the end of the
                   transfer (no Stop is issued), and the next transfer will
                   begin with a Restart rather than a Start.


    callback returns a data list:
    [I2C_READ_REPORT, i2c_port, i2c_device_address, count of data bytes, data bytes,
    time-stamp]

    I2C_READ_REPORT = 10

    &#34;&#34;&#34;

    if not callback:
        if self.shutdown_on_exception:
            self.shutdown()
        raise RuntimeError(&#39;I2C Read: A callback function must be specified.&#39;)

    # i2c_port = 0 for port 0
    if i2c_port == 0:
        if not self.i2c_0_active:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(
                &#39;I2C Write: set_pin_mode_i2c never called for i2c port 0.&#39;)
        else:
            self.i2c_callback = callback

    else:
        if not i2c_port == 1:
            if not self.i2c_0_active:
                if self.shutdown_on_exception:
                    self.shutdown()
                raise RuntimeError(
                    &#39;I2C Write: set_pin_mode_i2c never called for i2c port 1.&#39;)
            else:
                self.i2c_callback2 = callback

    command = [PrivateConstants.I2C_READ, i2c_port, address, register,
               number_of_bytes, no_stop]

    # no register specified
    if not register:
        command[3] = PrivateConstants.I2C_NO_REGISTER

    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.i2c_write"><code class="name flex">
<span>def <span class="ident">i2c_write</span></span>(<span>self, address, args, i2c_port=0, no_stop=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to an i2c device.</p>
<p>:param address: i2c device address</p>
<p>:param args: A variable number of bytes to be sent to the device
passed in as a list.
NOTE: THIS MUST BE IN THE FORM OF A LIST.</p>
<p>:param i2c_port: 0= port 0, 1 = port 1</p>
<p>:param no_stop: If true, master retains control of the bus at the end of the
transfer (no Stop is issued), and the next transfer will
begin with a Restart rather than a Start.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def i2c_write(self, address, args, i2c_port=0, no_stop=False):
    &#34;&#34;&#34;
    Write data to an i2c device.

    :param address: i2c device address

    :param args: A variable number of bytes to be sent to the device
                 passed in as a list.
                 NOTE: THIS MUST BE IN THE FORM OF A LIST.

    :param i2c_port: 0= port 0, 1 = port 1

    :param no_stop: If true, master retains control of the bus at the end of the
                   transfer (no Stop is issued), and the next transfer will
                   begin with a Restart rather than a Start.



    &#34;&#34;&#34;
    if not i2c_port:
        if not self.i2c_0_active:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(
                &#39;I2C Write: set_pin_mode i2c never called for i2c port 0.&#39;)

    elif i2c_port:
        if not self.i2c_1_active:
            if self.shutdown_on_exception:
                self.shutdown()
            raise RuntimeError(
                &#39;I2C Write: set_pin_mode i2c never called for i2c port 2.&#39;)

    command = [PrivateConstants.I2C_WRITE, i2c_port, address, len(args), no_stop]

    for item in args:
        command.append(item)

    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.loop_back"><code class="name flex">
<span>def <span class="ident">loop_back</span></span>(<span>self, start_character, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a debugging method to send a character to the
pico device, and have the device loop it back.</p>
<p>:param start_character: The character to loop back. It should be
an integer.</p>
<p>:param callback: Looped back character will appear in the callback method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop_back(self, start_character, callback=None):
    &#34;&#34;&#34;
    This is a debugging method to send a character to the
    pico device, and have the device loop it back.

    :param start_character: The character to loop back. It should be
                            an integer.

    :param callback: Looped back character will appear in the callback method

    &#34;&#34;&#34;
    command = [PrivateConstants.LOOP_COMMAND, ord(start_character)]
    self.loop_back_callback = callback
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.neo_pixel_set_value"><code class="name flex">
<span>def <span class="ident">neo_pixel_set_value</span></span>(<span>self, pixel_number, r=0, g=0, b=0, auto_show=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the selected pixel in the pixel array on the Pico to
the value provided.</p>
<p>:param pixel_number: pixel number</p>
<p>:param r: red value 0-255</p>
<p>:param g: green value 0-255</p>
<p>:param b: blue value 0-255</p>
<p>:param auto_show: call show automatically</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neo_pixel_set_value(self, pixel_number, r=0, g=0, b=0, auto_show=False):
    &#34;&#34;&#34;
    Set the selected pixel in the pixel array on the Pico to
    the value provided.

    :param pixel_number: pixel number

    :param r: red value 0-255

    :param g: green value 0-255

    :param b: blue value 0-255

    :param auto_show: call show automatically

    &#34;&#34;&#34;
    if not self.neopixels_initiated:
        raise RuntimeError(&#39;You must call set_pin_mode_neopixel first&#39;)

    if pixel_number &gt; self.number_of_pixels:
        raise RuntimeError(&#39;Pixel number is out of legal range&#39;)

    if r and g and b not in range(256):
        raise RuntimeError(&#39;Pixel value must be in the range of 0-255&#39;)

    command = [PrivateConstants.SET_NEO_PIXEL, pixel_number, r, g, b, auto_show]
    self._send_command(command)

    if auto_show:
        self.neopixel_show()</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.neopixel_clear"><code class="name flex">
<span>def <span class="ident">neopixel_clear</span></span>(<span>self, auto_show=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all pixels</p>
<p>:param auto_show: call show automatically</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neopixel_clear(self, auto_show=True):
    &#34;&#34;&#34;
    Clear all pixels

    :param auto_show: call show automatically

    &#34;&#34;&#34;
    if not self.neopixels_initiated:
        raise RuntimeError(&#39;You must call set_pin_mode_neopixel first&#39;)
    command = [PrivateConstants.CLEAR_ALL_NEO_PIXELS, auto_show]
    self._send_command(command)
    if auto_show:
        self.neopixel_show()</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.neopixel_fill"><code class="name flex">
<span>def <span class="ident">neopixel_fill</span></span>(<span>self, r=0, g=0, b=0, auto_show=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill all pixels with specified value</p>
<p>:param r: 0-255</p>
<p>:param g: 0-255</p>
<p>:param b: 0-255</p>
<p>:param auto_show: call show automatically</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neopixel_fill(self, r=0, g=0, b=0, auto_show=True):
    &#34;&#34;&#34;
    Fill all pixels with specified value

    :param r: 0-255

    :param g: 0-255

    :param b: 0-255

    :param auto_show: call show automatically
    &#34;&#34;&#34;
    if not self.neopixels_initiated:
        raise RuntimeError(&#39;You must call set_pin_mode_neopixel first&#39;)
    if r and g and b not in range(256):
        raise RuntimeError(&#39;Pixel value must be in the range of 0-255&#39;)
    command = [PrivateConstants.FILL_ALL_NEO_PIXELS, r, g, b, auto_show]
    self._send_command(command)

    if auto_show:
        self.neopixel_show()</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.neopixel_show"><code class="name flex">
<span>def <span class="ident">neopixel_show</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the NeoPixel buffer stored in the Pico to the NeoPixel strip.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neopixel_show(self):
    &#34;&#34;&#34;
    Write the NeoPixel buffer stored in the Pico to the NeoPixel strip.

    &#34;&#34;&#34;
    if not self.neopixels_initiated:
        raise RuntimeError(&#39;You must call set_pin_mode_neopixel first&#39;)
    command = [PrivateConstants.SHOW_NEO_PIXELS]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.pwm_write"><code class="name flex">
<span>def <span class="ident">pwm_write</span></span>(<span>self, pin, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the specified pin to the specified value.</p>
<p>:param pin: pico GPIO pin number</p>
<p>:param value: pin value - size is determined by what was set for value_range
when set_pin_mode_pwm_output was called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pwm_write(self, pin, value):
    &#34;&#34;&#34;
    Set the specified pin to the specified value.

    :param pin: pico GPIO pin number

    :param value: pin value - size is determined by what was set for value_range
    when set_pin_mode_pwm_output was called.

    &#34;&#34;&#34;
    if self.pico_pins[pin] != PrivateConstants.AT_PWM_OUTPUT:
        raise RuntimeError(&#39;pwm_write: You must set the pin mode before performing &#39;
                           &#39;a PWM write.&#39;)
    value_msb = value &gt;&gt; 8
    value_lsb = value &amp; 0xff
    command = [PrivateConstants.PWM_WRITE, pin, value_msb, value_lsb]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_analog_input"><code class="name flex">
<span>def <span class="ident">set_pin_mode_analog_input</span></span>(<span>self, adc_number, differential=0, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as an analog input.</p>
<p>:param adc_number: ADC Number 0-3 - ADC 3 is the temp sensor</p>
<p>:param differential: difference in previous to current value before
report will be generated</p>
<p>:param callback: callback function</p>
<p>callback returns a data list:</p>
<p>[pin_type, pin_number, pin_value, raw_time_stamp]</p>
<p>The pin_type for analog input pins = 3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_analog_input(self, adc_number, differential=0, callback=None):
    &#34;&#34;&#34;
    Set a pin as an analog input.

    :param adc_number: ADC Number 0-3 - ADC 3 is the temp sensor

    :param differential: difference in previous to current value before
                         report will be generated

    :param callback: callback function


    callback returns a data list:

    [pin_type, pin_number, pin_value, raw_time_stamp]

    The pin_type for analog input pins = 3

    &#34;&#34;&#34;
    # make sure adc number is in range
    if not 0 &lt; adc_number &lt; 5:
        raise RuntimeError(&#39;Invalid ADC Number&#39;)
    self._set_pin_mode(adc_number, PrivateConstants.AT_ANALOG, differential,
                       callback=callback)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_digital_input"><code class="name flex">
<span>def <span class="ident">set_pin_mode_digital_input</span></span>(<span>self, pin_number, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a digital input.</p>
<p>:param pin_number: pico GPIO pin number</p>
<p>:param callback: callback function</p>
<p>callback returns a data list:</p>
<p>[pin_type, pin_number, pin_value, raw_time_stamp]</p>
<p>The pin_type for digital input pins = 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_digital_input(self, pin_number, callback=None):
    &#34;&#34;&#34;
    Set a pin as a digital input.

    :param pin_number: pico GPIO pin number

    :param callback: callback function


    callback returns a data list:

    [pin_type, pin_number, pin_value, raw_time_stamp]

    The pin_type for digital input pins = 2

    &#34;&#34;&#34;
    self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT, callback=callback)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_digital_input_pull_down"><code class="name flex">
<span>def <span class="ident">set_pin_mode_digital_input_pull_down</span></span>(<span>self, pin_number, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a digital input with pull down enabled.</p>
<p>:param pin_number: pico GPIO pin number</p>
<p>:param callback: callback function</p>
<p>callback returns a data list:</p>
<p>[pin_type, pin_number, pin_value, raw_time_stamp]</p>
<p>The pin_type for digital input pins with pullups enabled = 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_digital_input_pull_down(self, pin_number, callback=None):
    &#34;&#34;&#34;
    Set a pin as a digital input with pull down enabled.

    :param pin_number: pico GPIO pin number

    :param callback: callback function


    callback returns a data list:

    [pin_type, pin_number, pin_value, raw_time_stamp]

    The pin_type for digital input pins with pullups enabled = 2

    &#34;&#34;&#34;
    self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT_PULL_DOWN,
                       callback=callback)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_digital_input_pullup"><code class="name flex">
<span>def <span class="ident">set_pin_mode_digital_input_pullup</span></span>(<span>self, pin_number, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a digital input with pullup enabled.</p>
<p>:param pin_number: pico GPIO pin number</p>
<p>:param callback: callback function</p>
<p>callback returns a data list:</p>
<p>[pin_type, pin_number, pin_value, raw_time_stamp]</p>
<p>The pin_type for digital input pins with pullups enabled = 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_digital_input_pullup(self, pin_number, callback=None):
    &#34;&#34;&#34;
    Set a pin as a digital input with pullup enabled.

    :param pin_number: pico GPIO pin number

    :param callback: callback function


    callback returns a data list:

    [pin_type, pin_number, pin_value, raw_time_stamp]

    The pin_type for digital input pins with pullups enabled = 2

    &#34;&#34;&#34;
    self._set_pin_mode(pin_number, PrivateConstants.AT_INPUT_PULLUP,
                       callback=callback)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_digital_output"><code class="name flex">
<span>def <span class="ident">set_pin_mode_digital_output</span></span>(<span>self, pin_number)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a pin as a digital output pin.</p>
<p>:param pin_number: pico GPIO pin number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_digital_output(self, pin_number):
    &#34;&#34;&#34;
    Set a pin as a digital output pin.

    :param pin_number: pico GPIO pin number
    &#34;&#34;&#34;

    self._set_pin_mode(pin_number, PrivateConstants.AT_OUTPUT)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_i2c"><code class="name flex">
<span>def <span class="ident">set_pin_mode_i2c</span></span>(<span>self, i2c_port=0, sda_gpio=4, scl_gpio=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Establish the standard pico i2c pins for i2c utilization.</p>
<p>:param i2c_port: 0 = i2c0, 1 = i2c1</p>
<p>:param sda_gpio: gpio pin assigned to SDA</p>
<p>:param scl_gpio: gpio pin assigned to SCL</p>
<h2 id="notes">Notes</h2>
<ol>
<li>THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE <br></li>
<li>Callbacks are set within the individual i2c read methods of this
API.</li>
</ol>
<p>See i2c_read, and i2c_write</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_i2c(self, i2c_port=0, sda_gpio=4, scl_gpio=5):
    &#34;&#34;&#34;
    Establish the standard pico i2c pins for i2c utilization.

    :param i2c_port: 0 = i2c0, 1 = i2c1

    :param sda_gpio: gpio pin assigned to SDA

    :param scl_gpio: gpio pin assigned to SCL


    NOTES:
           1. THIS METHOD MUST BE CALLED BEFORE ANY I2C REQUEST IS MADE &lt;br&gt;
           2. Callbacks are set within the individual i2c read methods of this
          API.

          See i2c_read, and i2c_write

    &#34;&#34;&#34;
    # determine if the i2c port is specified correctly
    if i2c_port not in [0, 1]:
        raise RuntimeError(&#39;i2c port must be either a 0 or 1&#39;)
    # determine if the sda and scl gpio&#39;s are valid
    if sda_gpio not in self.i2c_sda_pins:
        raise RuntimeError(f&#39;GPIO {sda_gpio} is an invalid i2c SDA GPIO&#39;)
    if scl_gpio not in self.i2c_scl_pins:
        raise RuntimeError(f&#39;GPIO {scl_gpio} is an invalid i2c SCL GPIO&#39;)

    # are both GPIOs available?
    if not self.i2c_sda_pins[sda_gpio] == 255:
        raise RuntimeError(f&#39;GPIO SDA pin {sda_gpio} is already in use.&#39;)
    if not self.i2c_scl_pins[scl_gpio] == 255:
        raise RuntimeError(f&#39;GPIO SCL pin {scl_gpio} is already in use.&#39;)
    # both pins available - mark the sda and scl dictionaries appropriately
    self.i2c_sda_pins[sda_gpio] = self.i2c_scl_pins[scl_gpio] = i2c_port

    # now mark the pico_pins dictionary for these pins
    self.pico_pins[sda_gpio] = self.pico_pins[scl_gpio] = PrivateConstants.AT_I2C

    # determine if the specified sda or scl pin has already been
    # assigned.

    # test for i2c port 0
    if not i2c_port:
        self.i2c_0_active = True
    # port 1
    else:
        self.i2c_1_active = True

    command = [PrivateConstants.I2C_BEGIN, i2c_port, sda_gpio, scl_gpio]
    self._send_command(command)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_neopixel"><code class="name flex">
<span>def <span class="ident">set_pin_mode_neopixel</span></span>(<span>self, pin_number=28, num_pixels=8, fill_r=0, fill_g=0, fill_b=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the pico for NeoPixel control. Fill with rgb values specified.</p>
<p>Default: Set all the pixels to off.</p>
<p>:param pin_number: neopixel GPIO control pin</p>
<p>:param num_pixels: number of pixels in the strip</p>
<p>:param fill_r: initial red fill value 0-255</p>
<p>:param fill_g: initial green fill value 0-255</p>
<p>:param fill_b: initial blue fill value 0-255</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_neopixel(self, pin_number=28, num_pixels=8,
                          fill_r=0, fill_g=0, fill_b=0):
    &#34;&#34;&#34;
    Initialize the pico for NeoPixel control. Fill with rgb values specified.

    Default: Set all the pixels to off.

    :param pin_number: neopixel GPIO control pin

    :param num_pixels: number of pixels in the strip

    :param fill_r: initial red fill value 0-255

    :param fill_g: initial green fill value 0-255

    :param fill_b: initial blue fill value 0-255


    &#34;&#34;&#34;
    if fill_r or fill_g or fill_g not in range(256):
        raise RuntimeError(&#39;Pixel value must be in the range of 0-255&#39;)

    self.number_of_pixels = num_pixels

    command = [PrivateConstants.INITIALIZE_NEO_PIXELS, pin_number,
               self.number_of_pixels, fill_r, fill_g, fill_b]

    self._send_command(command)

    self.pico_pins[pin_number] = PrivateConstants.AT_NEO_PIXEL

    self.neopixels_initiated = True</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_pwm_output"><code class="name flex">
<span>def <span class="ident">set_pin_mode_pwm_output</span></span>(<span>self, pin_number, value_range=255)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable a pin as a PWM pin. Maximum number of PWMs is 16.</p>
<p>:param pin_number: pico GPIO pin number</p>
<p>:param value_range: value range - 16 bits</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_pin_mode_pwm_output(self, pin_number, value_range=255):
    &#34;&#34;&#34;
    Enable a pin as a PWM pin. Maximum number of PWMs is 16.

    :param pin_number: pico GPIO pin number

    :param value_range: value range - 16 bits
    &#34;&#34;&#34;

    if pin_number in self.pico_pins:
        self.pico_pins[pin_number] = PrivateConstants.AT_PWM_OUTPUT
        if self.pwm_active_count &gt;= 15:
            raise RuntimeError(
                &#39;set_pin_mode_pwm_output: number of active PWM pins is at maximum&#39;)

        if value_range &gt; 0xffff:
            raise RuntimeError(
                &#39;set_pin_mode_pwm_output: value_range is limited to 16 bits&#39;)

        self.pwm_active_count += 1

        self._set_pin_mode(pin_number, PrivateConstants.AT_PWM_OUTPUT,
                           value_range=value_range)
    else:
        raise RuntimeError(&#39;Gpio Pin Number is invalid&#39;)</code></pre>
</details>
</dd>
<dt id="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.shutdown"><code class="name flex">
<span>def <span class="ident">shutdown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method attempts an orderly shutdown
If any exceptions are thrown, they are ignored.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutdown(self):
    &#34;&#34;&#34;
    This method attempts an orderly shutdown
    If any exceptions are thrown, they are ignored.
    &#34;&#34;&#34;
    self.shutdown_flag = True

    self._stop_threads()

    # try:
    command = [PrivateConstants.STOP_ALL_REPORTS]
    self._send_command(command)
    time.sleep(.2)
    if self.reset_on_shutdown:
        command = [PrivateConstants.RESET_BOARD]
        self._send_command(command)
        time.sleep(.2)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="telemetrix_rpi_pico" href="index.html">telemetrix_rpi_pico</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico">TelemetrixRpiPico</a></code></h4>
<ul class="">
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.digital_write" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.digital_write">digital_write</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.disable_all_reporting" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.disable_all_reporting">disable_all_reporting</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.disable_analog_reporting" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.disable_analog_reporting">disable_analog_reporting</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.disable_digital_reporting" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.disable_digital_reporting">disable_digital_reporting</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.enable_analog_reporting" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.enable_analog_reporting">enable_analog_reporting</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.enable_digital_reporting" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.enable_digital_reporting">enable_digital_reporting</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.get_pico_pins" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.get_pico_pins">get_pico_pins</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.i2c_read" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.i2c_read">i2c_read</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.i2c_write" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.i2c_write">i2c_write</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.loop_back" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.loop_back">loop_back</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.neo_pixel_set_value" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.neo_pixel_set_value">neo_pixel_set_value</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.neopixel_clear" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.neopixel_clear">neopixel_clear</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.neopixel_fill" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.neopixel_fill">neopixel_fill</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.neopixel_show" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.neopixel_show">neopixel_show</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.pwm_write" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.pwm_write">pwm_write</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_analog_input" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_analog_input">set_pin_mode_analog_input</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_digital_input" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_digital_input">set_pin_mode_digital_input</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_digital_input_pull_down" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_digital_input_pull_down">set_pin_mode_digital_input_pull_down</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_digital_input_pullup" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_digital_input_pullup">set_pin_mode_digital_input_pullup</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_digital_output" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_digital_output">set_pin_mode_digital_output</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_i2c" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_i2c">set_pin_mode_i2c</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_neopixel" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_neopixel">set_pin_mode_neopixel</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_pwm_output" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.set_pin_mode_pwm_output">set_pin_mode_pwm_output</a></code></li>
<li><code><a title="telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.shutdown" href="#telemetrix_rpi_pico.telemetrix_rpi_pico.TelemetrixRpiPico.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>